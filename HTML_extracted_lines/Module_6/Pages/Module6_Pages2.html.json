{"content": {"Introduction": {"para_sentences": {"para_0": "In this section we explore one popular problem called Huffman Codes that is solved using a Greedy Algorithm. As you go through this section, analyze the approach taken towards solving and proving a greedy algorithm."}, "li_sentences": {}}, "Huffman Codes": {"para_sentences": {"para_0": "We know that all the text, numbers etc are represented in binary format in our computers. Consider the problem of representing some text, say - \"this is a big secret message\" in binary, but the condition is that we need to use minimum possible binary bits and it should be easy decode the text back from binary. Huffman Coding one of the commonly used techniques to solve this problem (this problem is called lossless data compression). Let us explore this technique.\u00a0", "para_1": "Let us assume our imaginary message to be \"aaaaaaaabbbcdeeee\" (8 a's, 3 b's, 1c, 1d, 4 e's)", "para_2": "Let us assign each character with some binary representation.", "para_3": "The binary text will be: 000 000 000.......100. Our message length will be 51 bits. Is it optimal? Maybe we can shorten it.", "para_4": "Can we optimize the length of the message by making it shorter, by using a different binary code representation in such a way that the length of the binary code is variable based on the frequency of the occurrence of the character? We can represent the characters that appear a maximum number of times (high-frequency characters) with a shorter code and characters that appear least number of times (low-frequency characters) with longer code. So, the idea is to use a variable-length code.\u00a0", "para_5": "Now using this code, our message will be 1111111100000000110101010101. Our message length is now 24 bits. But can we decode these bits back to our message? When decoding should we read the last three bits as d, or read last two bits as e? Both appear correct based on the code.", "para_6": "This approach appears optimal but decoding seems to be challenging. So we need to design a better approach to represent the character based on the frequency but in such a way that we don't have ambiguity.\u00a0", "para_7": "The idea is to represent the characters in the form of a binary tree, such that the characters with the least frequency will have the maximum depth. Here is an example:", "para_8": "If there are two characters a, b both with the same frequency of 4. Our binary tree will be as shown below. Each node represents the frequency of occurrence of the character. We assign a binary symbol (0 or 1) to each branch.", "para_9": "", "para_10": "Based on this tree, we can represent A:0 and B:1.\u00a0", "para_11": "The below video shows the method to construct a binary tree and how to decode the message. We first take the two characters with the lowest frequency and form a tree with two nodes. The root node will be the sum of the frequency of the lowest two nodes that we considered. Then we follow the same procedure with the remaining characters but we also include the frequency of the root node to build the tree. \u00a0Access video notes here\n\n\nActions\n\n\nPreview\nDownload\nAlternative formats\n\n.", "para_12": "\u00a0", "para_13": "\u00a0", "para_14": "When constructing the tree, at each step we want to pick two smallest frequencies from the available frequencies including the one in our tree's current root. For the characters and their frequency of occurrence given below, construct a binary tree to generate Huffman codes. Based on your tree answer below questions.", "para_15": "\u00a0", "para_16": "Now that we understand the approach to solve the problem, let us write our algorithm to implement it. For this, our knowledge of data structures will come in handy. As you might have noticed that while building the tree we are repeatedly asking - what is the minimum frequency among the list of frequencies. This gives us an idea that we need to sort the frequencies. We would be generating new frequency values (by combining two minimum frequencies) and this new value needs to be in sorted order with the previous list of frequencies so that we can get two minimum frequencies repeatedly, this would be done until we build the complete tree. Hence, we need to represent our frequency values in a way to perform these operations with the best time complexity.\u00a0 We can use the min-heap data structure for this purpose.\u00a0", "para_17": "You can refresh your knowledge of heap using this wiki link\n\n\nLinks to an external site..\u00a0", "para_18": "View the slides below for the step by step explanation of the pseudocode.", "para_19": "Insert operation into Q takes log n time and we are performing this 2n-1 times, each time taking out two nodes and adding a new node.", "para_20": "\u00a0"}, "li_sentences": {}}, "Exercises": {"para_sentences": {"para_0": "Write the pseudocode to perform encode a message and decode a message from the tree that is constructed above.", "para_1": "\u00a0"}, "li_sentences": {}}, "Optional Additional Resources": {"para_sentences": {}, "li_sentences": {"ul_0": ["For the proof of correctness of the technique refer to Chapter 4 (Greedy Algorithms) Section 4", "If you are interested in a fun read of the story behind Huffman solving this problem  you can read here: https://www"]}}}, "heading_sentences": ["Exploration 6", "2: Greedy Algorithms - Huffman Coding Problem"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]]}, "preh2_links": {}}