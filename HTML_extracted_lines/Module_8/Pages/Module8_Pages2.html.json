{"content": {"Introduction": {"para_sentences": {"para_0": "In this section, we will explore another algorithm that is used to compute a minimum spanning tree. This algorithm is called Kruskal's Algorithm. It is slightly different from Prim's algorithm.", "para_1": "As you go through this section, try to answer the following questions:"}, "li_sentences": {"ul_0": ["What is Kruskal's algorithm?", "How to implement Kruskal's algorithm?"]}}, "KRUSKAL'S ALGORITHM": {"para_sentences": {"para_0": "Kruskal's algorithm uses a greedy approach to find a minimum spanning tree. The idea is to look for the edge with minimum length if the edge does not create a cycle then add it to the tree.", "para_1": "The below deck demonstrates the construction of the tree.", "para_2": "\u00a0", "para_3": "\u00a0", "para_4": "\u00a0", "para_5": "A. Simple pseudocode for Kruskal's algorithm can be given by:", "para_6": "\u00a0The time complexity to implement this code using a straight forward approach: Cost to sort E will be O(E log E). The cost to find if edge e would form any cycles with MST, which can be done using BFS or DFS on the graph MST by comparing each edge. This will take a time of O(V). This is done E times. The total time complexity for the loop will be O(EV). Hence, the algorithm will have a time complexity of O(EV).", "para_7": "Let us see if we can improve this running time. The costly operation that we are performing here is to check if e forms cycle with MST, the disjoint set data structure.", "para_8": "Let us look briefly about disjoint set data structure. Disjoint set data structure stores a collection of a disjoint set of items. In other words, it stores a partition of set of objects in disjoint sets. Among all the operations that it supports two that would be useful to us is to find the set S where an object x belongs to (Find(x)) and to merge two sets and form a single set (Union(x,y))", "para_9": "Find(x) = returns the set to which x belongs to.", "para_10": "Union(x,y) = will merge the two sets x and y.", "para_11": "Suppose, to begin with, we have a graph with vertices (A, B, C, D, E, F).\u00a0", "para_12": "", "para_13": "Using the Disjoint set data structure each object is represented with a parent. When we have a single object in the set each one is its own parent. When we merge two disjoint sets we update the objects to point to a common parent/leader. When we merge vertices A, B, and C, we can choose one of these as the leader, let us say we pick A. Similarly when we merge D, E, F we pick one leader among these vertices, let's say D. We now have two disjoint sets. Given a vertex, we can find which set it belongs in O(1) time by just querying for its leader. The below figure demonstrates the merge and operations on the vertices (A, B, C, D, E, F).\u00a0", "para_14": "The union operation can be performed in many ways to optimize the implementation. Rather than always appending the second set to the first set, we can always append the set that is smaller to the bigger set. To accomplish this we would have to maintain a rank of each tree, which might refer to the number of objects in the tree.", "para_15": "The union operation can be accomplished in logarithmic time complexity in the worst case. You can refer to this data structure in the supplementary help section on this page.\u00a0", "para_16": "For ease of implementation, we can write the pseudocode of Kruskal's as below. Where, to begin with, we will create a forest of trees with each vertex having its own tree. Then we greedily add the minimum weighted edge e that connects from u - v, such that u and v belong to different trees so that there are no cycles.\u00a0", "para_17": "\u00a0Firstly, we create a forest for each tree.", "para_18": "Then we greedily add the minimum weighted edge e, whose vertices do not belong to the same tree. This is to make sure that no cycles are created.", "para_19": "Then, we merge the two trees.", "para_20": "The operations:\u00a0 to verify 'u and v do not belong to the same tree' and 'merging u's tree with v's tree' can be accomplished by using sets.", "para_21": "We can use a disjoint set data structure to efficiently implement the algorithm.\u00a0", "para_22": "The pseudocode can be written as:", "para_23": "make_set(v) \u2014 Create a set containing only the vertex v in O(1) time. This would be performed a total of V times.", "para_24": "Find_set(v) \u2014 Return an set containing v in O(1). This would be performed 2E times, twice for each edge.", "para_25": "Union(u,v) - performs |V|- 1 operations (one for each edge in the minimum spanning tree) in amortized O(logV) time. This is performed a total of O(VlogV) times.", "para_26": "The sort operations dominate the running, which would be O(ElogE) to sort the edges. In graphs we have edges |E| at most of |V|2 (That will happen when all the vertices are connected with each other). We can replace E with |V|2 \u00a0and\u00a0 we will have a time complex of O(VlogV)."}, "li_sentences": {}}, "Exercises": {"para_sentences": {"para_0": "Union_set(a, b)", "para_1": "Sample input and output:", "para_2": "a: [1,2,3]", "para_3": "b: [4,5]", "para_4": "result: 4", "para_5": "The disjoint set operations are implemented in solution.py. Optionally, you can access the solution from the GitHub link\n\n\nLinks to an external site..", "para_6": ""}, "li_sentences": {"ul_0": ["Implement the union operation discussed under the Disjoint Set Data structure section"]}}}, "heading_sentences": ["Exploration 8", "2: Minimum Spanning Tree - Kruskal's Algorithm"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]]}, "preh2_links": {}}