{"content": {"Introduction": {"para_sentences": {"para_0": "In this module, we will see what is the minimum spanning tree. We will explore Prim's algorithm that is used to solve the minimum spanning tree problem.\u00a0", "para_1": "As you go through this section, try to answer the following questions:"}, "li_sentences": {"ul_0": ["Define minimum spanning tree?", "What is Prim's algorithm?", "How to implement Prim's algorithm?", "How to prove the correctness of Prim's algorithm?"]}}, "Minimum Spanning Tree": {"para_sentences": {"para_0": "Let us look at some terminology related to graphs that will help us explore this section.", "para_1": "By now you know what is a spanning tree for a graph. Let's see what is a minimum spanning tree. Given a weighted undirected graph G, the minimum spanning tree is that spanning tree of G whose cost (the sum of weights of edges) is the least among any other spanning tree of G.\u00a0", "para_2": "", "para_3": "\u00a0", "para_4": "A graph can have more than one minimum spanning trees.", "para_5": "Our problem is to find a minimum spanning tree for a given graph. This problem has numerous applications like in network design in telephone, electric, hydraulic sectors. For example, in telephone network design we want to connect all the nodes but minimize the length of the wire. In image processing, it is used to find the connected regions in an image. The algorithm is a starting step in solving other advanced graph problems.", "para_6": "If we take a graph that has V vertices, a total of VV-2 trees are possible. Hence, if you try to implement it using a brute force approach it will be exponential time, which is very slow.", "para_7": "There are two greedy algorithms that solve this problem:"}, "li_sentences": {"ol_0": ["Prim's algorithm", "Kruskal's algorithm"]}}, "PRIM'S ALGORITHM": {"para_sentences": {"para_0": "Prim's algorithm picks a random node in the graph and builds the spanning tree by using the greedy approach of selecting the edge with the least weight.\u00a0", "para_1": "Go through the below demonstration to understand the algorithm.", "para_2": "The pseudocode for this algorithm:", "para_3": "If we implement it in a naive way it will have a time complexity of O(VE). The while loop is executed V times and if we manually find the edge with the minimum value we will need to search E number of times for each V.", "para_4": "Can we make this faster? Yes, using our knowledge of data structures. We can use a min-heap using priority queue and make this faster. Watch the below video for the explanation. Access video notes here\n\n\nActions\n\n\nPreview\nDownload\nAlternative formats\n\n.", "para_5": "\u00a0", "para_6": "\u00a0", "para_7": "\u00a0", "para_8": "Let us prove that Prim's algorithm computes a MST.", "para_9": "We will\u00a0prove this by induction.", "para_10": "Let us denote the graph with G and the edges as (e1,e2....ek......).", "para_11": "The loop invariant is that after every iteration of the while loop the tree T built by the algorithm is a subgraph of the minimum spanning tree. This will give us our induction hypothesis.\u00a0", "para_12": "Induction hypothesis:\u00a0 After every iteration, the tree T built by the algorithm is a subgraph of the MST.", "para_13": "Base case: At the start of the loop the T has only one node s which is part of the MST (Since MST should have all the vertices otherwise it will not be called a MST). The base case is true.", "para_14": "Induction case: We will prove this by contradiction.", "para_15": "At some point in the algorithm, we would have built a tree T that is part of the MST. The algorithms next adds edge e that has one end connecting to vertex u which is in the region of T. Assume that e does not belong to MST. If we add e to MST it will create a cycle, since each vertex is already connected to every other edge.\u00a0", "para_16": "In the MST of the graph, there must be another edge e* that is connecting vertex u.\u00a0", "para_17": "Since from vertex u among e and e*, edge e was picked by the algorithm, this implies weight(e) <= weight(e*)", "para_18": "Now, if we remove e* from tree M and add edge e. The overall cost of MST might reduce further. Which contradicts our definition of MST. Hence the loop invariant is maintained during the execution of the loop.", "para_19": "Termination: The loop would terminate when all vertices are included in the tree and the tree T built is an MST.", "para_20": "\u00a0"}, "li_sentences": {}}, "Optional Additional Resources": {"para_sentences": {"para_0": "Refer to the following resources for additional reading."}, "li_sentences": {"ul_0": ["CLRS textbook  Chapter 23  Section 23"]}}}, "heading_sentences": ["Exploration 8", "1: Minimum Spanning Tree -  Prim's Algorithm"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]], "ol_0": [[]]}, "preh2_links": {}}