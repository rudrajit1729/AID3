{"content": {"Introduction": {"para_sentences": {"para_0": "Having come to almost the end of this class, now you know numerous problems of different time complexities ranging from a linear search that takes O(n) to an N-Queen problem that takes O(n!) time. When solving a problem we always want to ask can we do better to improve the time complexity? Now, let us see the world of problems on which still research is going on and scientists are trying to find a better solution. In a few cases, they are working to prove that they cannot find a better solution. We will explore all those in this and the next sections.", "para_1": "As you go through this section, try to answer the following questions:"}, "li_sentences": {"ul_0": ["What are the complexity classes?", "What is meant by P  NP  NP-Hard and NP-Complete?", "What are some examples of P and NP problems?", "What do we mean when we say a problem is NP-Complete?", "What do we mean by reduction?"]}}, "COMPLEXITY CLASSES": {"para_sentences": {"para_0": "When we say we're trying to make an algorithm faster, we must first define the metrics that make algorithms more or less efficient. Until merge sort and quick sort algorithms were developed, we thought n2 was the maximum efficiency that we could achieve for sorting problems.", "para_1": "In the first module, we said that any algorithm that takes 2n or more time complexity to run is extremely slow. Problems like 0/1 knapsack problems take 2n time. To refresh your memory, let us compare n2\u00a0with 2n. For instance, consider a problem with n = 100: When solved with an algorithm that has n2\u00a0time complexity, the algorithm takes less than a second to run, but the same problem would take 1017 (100 quadrillion) years to solve using 2n time complexity algorithm. With this in mind, we can come to the conclusion that \"polynomial\" execution time certainly is much more efficient than \"non-polynomial\" execution time.\u00a0", "para_2": "For ease of understanding while analyzing problems, computer scientists have classified problems based on the time required to solve them. This system of classification is called \u201ccomplexity classes\u201d. While we will not cover complexity classes in detail, we will look at them to the extent necessary for our topics of discussion.\u00a0", "para_3": "\u00a0To begin, we can classify problems types that can be solved in non-polynomial time as belonging to the \u201cNP class\u201d.\u00a0 Keep in mind that some of the problems within the types classified as NP may have solutions that run in polynomial time. Our NP class would include the following types of problems: Searching, Sorting, 0-1 Knapsack etc.\u00a0", "para_4": "\u00a0Among NP problems, those for which we are able to find a polynomial-time solution can be added to a subclass called \"P class\".", "para_5": "\u00a0", "para_6": "This is a general picture of NP class and P class.\u00a0", "para_7": "Now, let\u2019s arrange these problems on a scale that increases by time complexity. \u201cEasy\u201d refers to those problems that are solvable by efficient polynomial-time algorithms which are placed on the left of the scale, while \u201chard\u201d refers to those problems that are difficult. We don't know if there is a polynomial-time algorithm to solve these difficult problems, and they are placed to the right. Our arrangement should resemble the illustration below. Keep this graph in mind. We will add more items to it as we go.", "para_8": "\u00a0", "para_9": "Take an example game called number game, that you are playing with your friend. You are given numbers 1 to 9. Each player has to select a number on their turn. When all the numbers picked by a player adds up to 15 then the player wins the game.\u00a0", "para_10": "\u00a0", "para_11": "Say, you pick 4, your friend picks 8;", "para_12": "then you pick 5 and your friend picks 1;", "para_13": "then you pick 6 and you win the game : ).", "para_14": "This game is little difficult to play as-is, but let us say we arrange the numbers in the form of grid such that in the row, column and diagonally the numbers add up to 15, as shown below. Then the game is easy to play. To win you just have to select a number in a row/column/diagonal and stop your friend from doing the same. Does this appear similar to a game that we know of? Yes, the tic-tac-toe game\n\n\nLinks to an external site..", "para_15": "\u00a0", "para_16": "So, if we have an algorithm to solve the tic-tac-toe game, we can easily solve the number game. This is an abstract idea of converting one problem to another to solve it easily. We call it a reduction. The process of reducing one problem to another should be in polynomial time, otherwise, there is no point in reduction. Suppose we have an algorithm for some problem A. We want to solve a problem X. Let's assume X is reducible to problem A in polynomial time. Then we will first perform the polynomial-time reduction to get problem xandsolvex using A's algorithm. This is demonstrated in the below figure. This can be written as X\u2264pA (X can be reduced to A in p polynomial time). In other words, X is no harder than A. Note that reduction does not mean reducing a harder problem to an easier one, but in our context, it means transforming one problem to another.", "para_17": "\u00a0", "para_18": "Suppose you have a problem 'myProblem', that you are trying to solve in polynomial time, but you were not able to. After struggling for a week you are reminded of the concept of reduction. You decide to reduce one of the NP problems in NP to 'myProblem'. After thinking hard you pick some problem NPx from the set of NP-Class (not in P-Class) and reduce NPx to 'myProblem' in polynomial time. Since you were able to do this, you can declare that your problem is not solvable in polynomial time but it belongs to NP-class.", "para_19": "For this purpose, can you choose any problem from the NP-class? Well, no. You should pick from 'the' most difficult problems from NP class. But, what are those? Scientists have picked such problems from NP-class such that other problems in NP can be reduced to these and called these class of problems as NP-Hard. These problems are the hardest problems in NP-Class.\u00a0", "para_20": "\u00a0", "para_21": "Now coming to 'myProblem' if you are able to reduce an NP-Hard problem to 'myProblem', with full confidence you can say that your problem is not solvable in polynomial time as you have proved that it is similar to one of the hardest problems in Complexity Class. Now, it is the work of scientists to solve your problem, or you become a scientist and solve it.\u00a0", "para_22": "The NP-Hard class extends beyond the NP-Class. To understand why? Let us define our NP-Class.", "para_23": "NP does not mean Non-polynomial, it means Non-Deterministic Polynomial. To simply put it, as we discussed before it includes those problems that cannot be solved in polynomial time, but there is an additional property of these, these can be verified in polynomial time.", "para_24": "To understand this let us take the Sudoku game. Rules of the game are that we fill numbers from 1 to 9 in the grids such that no number repeats itself in a row and a column, additionally, no number should repeat in each grid of 9 squares marked by thick lines. To solve this game, let us first look at the first grid, which already has numbers {4,2}. So the first cell can contain numbers {1, 3, 5, 7} excluding 6 and 9 because they are already present in the first column and the first row respectively. This can be done in 4! ways, similarly, we can check the next cell. The number of possibilities grows the time complexity of the solution to a non-polynomial degree. But if we are given a filled Sudoku puzzle, it can be verified in N2 time (polynomial time). Sudoku belongs to NP-Class but not to P-Class. You might think, well computers can solve Sudoku quickly why is this in NP? At this point, we should not forget that we are speaking about asymptotic growth of the problem as the input size increases i.e. the size of the Sudoku puzzle increases.", "para_25": "\u00a0Original image source: Wikipedia\n\n\nLinks to an external site.", "para_26": "Why the word Non-deterministic? 'In computer science, a nondeterministic algorithm is an algorithm that, even for the same input, can exhibit different behaviors on different runs, as opposed to a deterministic algorithm.'1This means we have a magic machine that somehow can give us the right answer for each input. If we had such a magic machine we give it each cell of Sudoku and it will give us the right answer in a constant time, then we can solve our Sudoku in polynomial time. : ) Hence the name Non-deterministic polynomial. Further discussion is beyond the scope of our course. For this course it is enough if you are able to tell:", "para_27": "NP-Hard problems include those that cannot be verified in polynomial time. But a special point to note about the NP-hard problems is that every problem in NP can be reduced to these problems.\u00a0", "para_28": "Now, there can be some problems in NP-Hard that really hard among the NP-class, that is every problem in NP can be reduced to these problems but these can be verified in polynomial time. These form the set of overlap between NP-Class and NP-Hard, these are called NP-Complete problems. A problem is NP-Complete if:", "para_29": "\u00a0", "para_30": "We will refer to P-class as P; and NP-Class as NP.", "para_31": "Is it true that we cannot solve any of the problems in NP in polynomial time? Maybe or maybe not! It is not proved that it is not possible. In fact, there is a million-dollar prize on this question: Is P = NP? Clay Mathematics Institute listed 'Millennium problems'\n\n\nLinks to an external site. for million dollar price for solving each one of them, P vs NP is one among them.", "para_32": "If we are able to solve one NP-Hard problem in polynomial time then all the problems in NP can be solved in polynomial time because all the problems in NP can be reduced to NP-Hard problems. This would collapse NP into P. We will leave the P vs NP question with this : ).", "para_33": "For now, remember that if we are able to solve one NP-Hard problem in polynomial time then all the problems in NP can be solved in polynomial time. This would mean P=NP, which is not true (as of now). We will use this statement to prove NP-Hard problems in the next section."}, "li_sentences": {"ul_0": ["It is in NP-Hard (i", "It is in NP (i"]}}, "Decision Problems": {"para_sentences": {"para_0": "Decision problems are those which can be answered in yes or no.", "para_1": "Examples:\u00a0", "para_2": "Other classification problems can be an optimization problem, where we are finding the best/optimum possible solution.", "para_3": "Examples:\u00a0", "para_4": "Each optimization problem can also be converted into a decision problem.", "para_5": "Example:", "para_6": "Why are we discussing decision problems? Historically for mathematical simplicity the discussion of P and NP is done in terms of decision problems. Here are more accurate definitions of P and NP.", "para_7": "P Class: P is a complexity class that represents the set of all decision problems that can be solved in polynomial time. That means any problem that is in P can produce a YES or NO answer in polynomial time.\u00a0\u00a0", "para_8": "NP Class: NP is a complexity class that represents the set of all decision problems for which the instances where the answer is \"yes\" have proofs that can be verified in polynomial time. So, to reword this, if we were given a solution to a problem and the answer sheet for that specific problem, we can confirm that the solution to the problem is in fact correct in polynomial time.", "para_9": "In the examples above we have shown that we can convert any optimization problem or any problem in general into a decision problem. And since the main difference between P and NP is whether or not a solution exist for the problem that can be found in polynomial time, it is important to phrase problems as decision problems, so that the appropriate comparison/analysis can be made.\u00a0", "para_10": "There is a more intense classification of complexity classes you can find on the Wikipedia website\n\n\nLinks to an external site., but we are considering a simplistic picture for this class.", "para_11": "Drag and drop the correct labels onto the correct drop zones."}, "li_sentences": {"ul_0": ["Is the given list of integers sorted?", "Given a graph G  is there a path connecting vertices U and V?"], "ul_1": ["Given a list of numbers  what is the maximum number?", "Given a graph G what is the minimum distance between vertices U and V?"], "ul_2": ["Optimization problem: Given a knapsack of capacity W and N[] items worth value V[]  what is the optimum way to fill the knapsack with these N items to maximize the value of the knapsack", "Decision problem: Given a knapsack of capacity W and N[] items worth value V[]"]}}, "Optional Resources": {"para_sentences": {"para_0": "If this topic interests you, then you might find the following optional resources interesting.", "para_1": "References:", "para_2": "1. https://en.wikipedia.org/wiki/Nondeterministic_algorithm"}, "li_sentences": {"ul_0": ["Should You Try To Solve P Vs NP? by Udacity on YouTube   Links to an external site", "P vs"]}}}, "heading_sentences": ["Exploration 9", "1: P  NP  NP-Complete  NP-Hard"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]], "ul_1": [[]], "ul_2": [[]]}, "preh2_links": {}}