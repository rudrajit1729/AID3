{"content": {"Introduction": {"para_sentences": {"para_0": "In the previous module, you have seen the basic idea behind the backtracking algorithm. In this section, we concretize our understanding of the approach to solve problems using the backtracking algorithm. We will solve the N-Queens Problem in this section.", "para_1": "As you go through this section, try to answer the following questions:"}, "li_sentences": {"ul_0": ["How to identify if a problem can be solved using the backtracking technique?", "How to implement a backtracking algorithm?"]}}, "N-Queens Problem": {"para_sentences": {"para_0": "A refresher from the previous module: In the backtracking technique, we find all possible solutions to a problem. We do this by incrementally building up the solution and discarding(or backtracking) from those solution paths that don't lead us to the goal.\u00a0", "para_1": "There are three elements to the backtracking technique:", "para_2": "N-Queens Problem: The problem is to place N queens on an NxN chessboard such that no two queens are attacking each other. According to the rules of chess, a queen can be attacked horizontally, vertically and diagonally. The below figure shows the attacking positions of a queen.", "para_3": "", "para_4": "The below figure shows the solution for a 5-Queen problem.", "para_5": "", "para_6": "To solve this problem our goal is to place all the N queens on the board such that no two queens are in the attacking position.", "para_7": "This problem can be solved incrementally by placing a queen in the first available cell and the second queen in the next non-attacking position and the third queen in the third non-attacking position and so on, until we are unable to find a non-attacking position for our queens. Then we backtrack to our last queen and try to solve it.", "para_8": "This problem can be solved using the backtracking technique since it has clearly defined constraints and we evaluate the available choices of the solution and if we exhaust all of our choices then we backtrack and explore other choices.", "para_9": "Let us look at the backtracking approach for the 4-Queen problem.", "para_10": "\u00a0", "para_11": "To solve this problem we can represent the board with a 2-dimensional\u00a0array (board[N][N]) and default all values to 0. If a queen is placed in a position we mark it as 1. The solution for the 4-Queen problem demonstrated above would be:", "para_12": "[[0, 1, 0, 0],", "para_13": "\u00a0[0, 0, 0, 1],", "para_14": "\u00a0[1, 0, 0, 0],", "para_15": "[0, 0, 1, 0]]", "para_16": "Think for a while and try to complete the pseudocode:", "para_17": "We are passing the board, the first row value, the number of queens and the remaining number of queens to be solved,\u00a0 to our recursive function.", "para_18": "When the remaining queens to be solved are 0, we have reached our base case.", "para_19": "\u00a0We are iterating through each cell in a row and checking if it can be attacked.", "para_20": "If the position is not attacked we place our queen in the cell, and solve for the remaining queens. We do so, by incrementing our row since we cannot place another queen in the same row.", "para_21": "If the above function call returns false, this implies we cannot place a queen in the row and column, then we backtrack to the previous queen by resetting the cell value to 0", "para_22": "\"is_attacked(row, col, board, N)\" is a constraint checking function, which validates that no other queen is present in the row, column and in diagonal positions.\u00a0", "para_23": "Try coding the solution in below code editor. The solution is in solution.py file. Optionally, you can access the solution from the GitHub link\n\n\nLinks to an external site..", "para_24": "", "para_25": "Time Complexity:", "para_26": "The outer for loop executes for n times. 'is_attacked(row, col, board, N)' has a time complexity of O(n). The if condition where is_attacked() function is called would have a time complexity of O(n2).\u00a0", "para_27": "The recursive call is called n-1 times. Since it is in the for loop that is executed n times, it would have a running time of nT(n-1), if T(n) is the running time of the solve_n_Queens() function.", "para_28": "We can write the recurrence relation as\u00a0", "para_29": "T(n) = O(n2) + nT(n-1)", "para_30": "Solving this recurrence relation would give the worst-case time complexity of O(n!).", "para_31": "This can be analyzed at a high level as, The first queen can be filled in n positions in the first row, the second queen in n-1 possible positions, the third queen in n-3 possible positions and so on. Resulting in time complexity of O(n\u2217(n\u22121)\u2217(n\u22122)....)\u00a0= O(n!)"}, "li_sentences": {"ol_0": ["Possible choices", "Constraints if any", "The goal"]}}, "Optional Additional Resources": {"para_sentences": {"para_0": "Refer to the following resources for additional reading."}, "li_sentences": {"ul_0": ["A different approach to solve this problem using one dimensional Array space is discussed in Chapter 2  Section 2"]}}}, "heading_sentences": ["Exploration 5", "1: Backtracking - N Queens Problem"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]], "ol_0": [[]]}, "preh2_links": {}}