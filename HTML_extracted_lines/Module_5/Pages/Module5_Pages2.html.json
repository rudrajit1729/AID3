{"content": {"Introduction": {"para_sentences": {"para_0": "In this section, you will see a couple of more problems that can be solved using the backtracking technique.\u00a0"}, "li_sentences": {}}, "Combination Sum Problem": {"para_sentences": {"para_0": "Problem: Given a sorted array of positive integers nums[] and a sum x, find all unique combinations of integers from the nums[] array whose sum is equal to x. Any integer in the array can be chosen an unlimited number of times.\u00a0", "para_1": "Additional requirements:", "para_2": "Elements in the combination ( e1,e2,e3,.....,ex) must be in the ascending order. (i.e. e1\u2264e2\u2264e3\u2264.....\u2264ex)", "para_3": "The combinations should be sorted in ascending order, i.e. the combination with the smallest first element should be printed first.", "para_4": "The solution should not contain duplicate combinations.", "para_5": "Return [], if there is no solution.", "para_6": "nums[] = [ 2 ,  3 ,  6 ,  7 ]; x =  7", "para_7": "Output: ", "para_8": "[2,2,3]", "para_9": "[7]\u00a0", "para_10": "nums[] = [1] ; x= 1", "para_11": "Output:\u00a0 [1]", "para_12": "\u00a0", "para_13": "", "para_14": "Solving this problem will be similar to the permutations problem that we saw in the previous module. We will iterate through each element in the array from the start of the array. When the sum of the combination of the choices is greater than the target value, we backtrack to the last selection and try a different choice. The below slideshow shows how the first result is built for example 1.", "para_15": "\u00a0", "para_16": "\u00a0", "para_17": "We are making a call to the helper function with the initial array, starting index, and an array to store the result, the target sum, and an empty array where we will store running combinations.", "para_18": "We are keeping track of the remainder of the sum after making a choice in the remainder variable. If the remainder is 0, we have obtained a result. If the remainder is less than 0, the sum has exceeded the target hence we discard it. These will form our base cases to break out of recursion.", "para_19": "We loop through the array and compute the result by making the choice of keeping each number in the array. Running choices are collected in the \"combination\" variable.", "para_20": "We backtrack by removing the last selection from the combination array (pop operation).", "para_21": "Time complexity: This is an exponential time program. If n is the length of the array in the question and k is the target sum. Time complexity will be O(nk)."}, "li_sentences": {}}, "Exercises": {"para_sentences": {"para_0": ""}, "li_sentences": {"ul_0": ["Implement the combination sum problem in below code editor"]}}, "Optional Additional Resources": {"para_sentences": {"para_0": "Refer to the following resources for additional reading."}, "li_sentences": {"ul_0": ["Solve the mini-sudoku problem explained in this link on Brilliant Website   Links to an external site", "A variation of Combination Sum is provided in Chapter 2  Section 2"]}}}, "heading_sentences": ["Exploration 5", "2: Backtracking - Combination Sum Problem"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]]}, "preh2_links": {}}