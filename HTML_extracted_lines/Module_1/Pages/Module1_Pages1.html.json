{"content": {"Introduction": {"para_sentences": {"para_0": "As computer science students, knowing about algorithms is very important. But what is it that you should know?", "para_1": "In general, you should know how to write an algorithm that is 'correct' and 'efficient' and be able to communicate this to our colleagues, friends or an interviewers.", "para_2": "At the end of this section, you will be able to write an algorithm in pseudocode and define the framework for analyzing the efficiency of an algorithm (MLO1)."}, "li_sentences": {}}, "The Analysis Framework": {"para_sentences": {"para_0": "As you study this section, consider the following questions:", "para_1": "When given a problem description, a good programmer doesn't directly jump to his or her favorite editor to start coding. One would follow these steps:", "para_2": "Understand the problem:", "para_3": "Restate the problem in terms of math objects:", "para_4": "Sample problem statement: Sort a sequence of numbers into non-decreasing order.", "para_5": "Formally defining the sorting problem:", "para_6": "Input: A sequence of n numbers (a1, a2,.....,an).", "para_7": "Output: A reordered input sequence (a1', a2',.......,an') such that a1'<a2'<......<an'", "para_8": "Write an algorithm:", "para_9": "An algorithm is a set of specific instructions intended to solve a problem. Algorithms are not programs, rather algorithms are abstract mechanical procedures that can be implemented in a programming language.", "para_10": "The clearest way to present an algorithm is using 'pseudocode', which conveys the instructions and structure of the algorithm clearly enough for us to implement it in the language of our choice. What separates pseudocode from \u201creal\u201d code is that in  pseudocode, we employ whatever expressive method is most clear and concise to specify a given algorithm. The convention that we follow here would appear similar to a Python language code, but we will not worry about syntax.", "para_11": "Here is an example of pseudocode for a problem: linearly search for an element k in an array A[0...n-1]:", "para_12": "Note sometimes for assignment\u00a0\u2190 or := is also used in pseudocode.", "para_13": "Prove that the algorithm is correct & analyze how fast the algorithm can run:", "para_14": "We will use formal techniques to prove the correctness of our algorithm and we will analyze the efficiency of our algorithm. We will see these two steps in detail in this section and next explorations.", "para_15": "Code the algorithm a programming language:", "para_16": "We finally write the code."}, "li_sentences": {"ul_0": ["What is an algorithm?", "How do we write pseudocode?", "What is the running time of an algorithm?", "What is the order of growth?"], "ul_1": ["Read the problem carefully", "Ask questions if you have doubts", "Do a few small examples by hand", "Think about special cases or 'boundary/edge' cases"]}}, "The Efficiency of an Algorithm": {"para_sentences": {"para_0": "When we have our pseudocode ready we should ask an important question: how quickly will the algorithm run? Ideally, we want the fastest possible algorithm for any particular problem. This is also a common question in technical interview coding rounds: how can you make the algorithm more efficient?\u00a0", "para_1": "Time efficiency is also called time complexity, it indicates how fast an algorithm runs (in other words, how complex the algorithm is in terms of the time it takes).", "para_2": "These questions about efficiency can be asked for memory (space) as well. Space complexity, refers to the number of memory units required by the algorithm in addition to the space needed for its input and output.", "para_3": "To identify the efficiency of an algorithm we would consider the time it takes to execute (run), i.e. the running time of the algorithm. For example, let's consider the problem to sort an array of integers and solve this problem using the BubbleSort technique (To revise bubble sort\u00a0 watch this quick explanation by Michael Sambol on Youtube\n\n\nLinks to an external site.).", "para_4": "Did you get it right? For our algorithm analysis are we interested in these? No. We just want to compare how fast one algorithm runs in comparison to others that solve the same problem, i.e. we want to compare the running times of algorithms.", "para_5": "But how do we measure running time? We can observe that the algorithm would take longer to sort larger arrays. Hence running time is a function of parameter n, where n is the input size of the algorithm. In the case of the BubbleSort algorithm n is the size of the input array.", "para_6": "Mathematically, the running time can be expressed as a function of T(n).", "para_7": "The choice of the appropriate parameters that would impact efficiency would depend on the algorithm and the problem. For example, how should we evaluate the efficiency of a spell-checking algorithm that examines the individual characters of its input? The parameters that impact efficiency are the number of the characters that make up the input words.", "para_8": "Now, let us see how to write the function of T(n). For this, we will look to see how many times each algorithm\u2019s operation is executed.", "para_9": "Consider the following algorithm that prints \"Hello\" n times:", "para_10": "Time taken to execute the code T(n) can be written as", "para_11": "T(n) = t1*1 + t2*1 + t3*(n+1) + t4*(n) + t5*1\u00a0", "para_12": "T(n) =\u00a0(t3+t4 )*n + (t1\u00a0+ t2 + t3\u00a0+ t5\u00a0)", "para_13": "We can express this running time as T(n)= an+b, where a and b are constants that depend on the execution time of each line. Where a = (t3+t4 ) and b = (t1\u00a0+ t2 + t3\u00a0+ t5\u00a0)", "para_14": "Since T(n) is of form an +b, we can say T(n) of PrintHelloNTimes is a linear function of n.", "para_15": "Try the question yourself, before proceeding further.", "para_16": "Here is the time calculation of each line.", "para_17": "For lines 3 & 4: ", "para_18": "When i = 0:", "para_19": "j = 0 to -1. # j loop will not enter in this case.", "para_20": "when i =1:", "para_21": "j = 0 to 0 # even in this case loop will not be entered.", "para_22": "when i =2:", "para_23": "j = 0 to 1 # loop will be executed for j = 0", "para_24": "when i = n", "para_25": "j = 0 to n-1 # loop will be executed for j=0,1,2,...,n-2", "para_26": "When i=0 and i =1, no comparisons are made by the program. When i=2, one comparison is made. When i=3, two comparisons are made, and so on. Thus, we can conclude that when i=m, m-1 comparisons are made. Hence, in an array of length n, it does 1+2+...+(n-2)+(n-1) comparisons. To solve this you might want to review the following summation formula.", "para_27": "  ", "para_28": "using the summation formula  1 +   2   +   \u22ef +   ( n \u2212   2 ) +   ( n \u2212   1 )\u00a0 can be written as, ", "para_29": "    ", "para_30": "So we can write T(n) as, T(n) = an2 + bn + c. We call this a quadratic function as n is raised to a power of 2.", "para_31": "When T(n) = an2 + bn + c, for simplifying the analysis we consider only the leading term of formula (e.g., an2), since the lower-order terms are relatively insignificant for large values of n.", "para_32": "T (n) \u2248 n2.", "para_33": "Now, let\u2019s see how the time taken by the algorithm changes as n grows. How much longer will the algorithm run if we double the input size? Since T(n) has a rate of growth of n2 running time will become\u00a022, i.e. 4 times. If input becomes 10 times T(n) will increase 100 times. In the analysis, it is the rate of growth or order of growth of the running time that really interests us.", "para_34": "By focusing on the order of growth we can compare different algorithms. Look at the following table which displays the order of growth of different functions. Observe how logarithm functions grow the slowest and on the other end 2n and n! grow so rapidly that we didn\u2019t even bother to calculate their values after the second row.", "para_35": "The below table shows running times for various input sizes for different algorithms on a processor that performs a million instructions per second. When running time exceeds 1025 it is recorded as 'very long'. Observe how the running time increases for different functions. Notice that the \u00a0algorithm runs in 20 seconds whereas the same takes days in case of quadratic function and years for polynomial functions.\u00a0", "para_36": "To get more practice on comparing these functions you can try the problems provided on KhanAcademy\n\n\nLinks to an external site. Look at the below image and see how each function grows with respect to others. To do this comparison, take a value of n say, 50 and compare each colored line's y-coordinate's N values.", "para_37": "    Source:   Wikipedia \n\n\nLinks to an external site.  ", "para_38": "Did you notice that log n grows very slowly in contrast to n, which grows linearly and, n! and 2n have exponential growth, which means they grow very rapidly?", "para_39": "Is it possible to have different running times for same input n? Let\u2019s see.", "para_40": "Consider LinearSearch Algorithm code that we have seen before.", "para_41": "What is its running time? T(n) = n", "para_42": "The LinearSearch searches for a given item (some search key k) in a list of n elements by checking successive elements in the list until either a match with the search key is found or the list is exhausted. The running time of this algorithm can be quite different for different lists of same size, n.", "para_43": "In the worst case, there would be no matching element and the algorithm would run till the end of the list, hence T(n) would be n. It is the largest possible running time of an algorithm. It generally captures efficiency.", "para_44": "In the best case, the first element itself might be the element that is being searched. Then T(n) would be 1. Best case running time is the minimum possible running time for the input of size n.", "para_45": "In the average case, the search element could be present anywhere in the list, and to calculate T(n) we need to use probabilistic analysis by randomly choosing a key from the elements of the list. Finding the average case is considerably more difficult than finding the worst case or best case.\u00a0", "para_46": "Hence, there are many algorithms for which running time depends not only on an input size but also on the specifics of a particular input."}, "li_sentences": {}}}, "heading_sentences": ["Exploration 1", "1: The Framework for Analyzing an Algorithm"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]], "ul_1": [[]]}, "preh2_links": {}}