{"content": {"Introduction": {"para_sentences": {"para_0": "In the previous exploration, we have seen that we can express a recursive solution in terms of a recurrence relation. In this section, we will dive deeper into recurrence relations and look at how to solve them (MLO2).\u00a0 As you master this you will begin to feel comfortable analyzing any complex recursive algorithm that we will see further in this course and that which you would come across outside academics.\u00a0"}, "li_sentences": {}}, "Recurrence Relations": {"para_sentences": {"para_0": "To analyze a recursive algorithm, similar to an iterative algorithm, we need to first express the algorithm in terms of an equation that expresses how the algorithm grows and then solve it to obtain the order of the growth.", "para_1": "An equation that expresses how a recursive algorithm grows is called a recurrence relation. Recurrence relation, as we have seen before, is an equation that is expressed in terms of its smaller values.\u00a0", "para_2": "Example 1:", "para_3": "Let us write recurrence relation for the Factorial function.", "para_4": "The if condition code runs in a constant time (say, c).\u00a0", "para_5": "If we represent the recursive function's execution by T(n), the recursive call in the else condition makes a subsequent call on T(n-1).", "para_6": "The recurrence relation can be written as:", "para_7": "T(n) = c1 or  when n=0 [This represents base case, and c1 is some constant]", "para_8": "\u00a0 when n>0 [This represents recursive case]", "para_9": "or, the recursive case can be written as:", "para_10": " when n>0 [since,  represents a constant time. ]", "para_11": "Example 2:", "para_12": "Let us write the recurrence relation of the Tower's of Hanoi code.", "para_13": "The if condition is executed in a constant time, c1.", "para_14": "The first recursive call 'hanoi(n - 1, source, target, temp)' makes a recursive\u00a0call on T(n-1)", "para_15": "Then there is a constant time (c2) check by if condition 'if source:'; followed by second recursive call on T(n-1).\u00a0", "para_16": "Note that in the recursive of the hanoi function although there are other parameters 'temp', 'source', 'target', we don't\u00a0have to present them in the recurrence relation as they are don't impact the running time of our algorithm,", "para_17": "The recurrence relation will be:", "para_18": "T(n) = c1 + T(n-1) + c2 + T(n-1) ", "para_19": "= 2T(n-1) + c\u00a0 \u00a0 \u00a0[for n>0, this is for the recursive case]", "para_20": "T(n) = c [for n=0, this is for the base case", "para_21": "Example 3:", "para_22": "Let's write recurrence relation for the below pseudocode of a foo function. Don't worry about what the algorithm does you will understand it as you read further.", "para_23": "foo is some function that takes as input: an array 'Arr' of size n, starting index of the array 'start' and last index of the array 'end'. We need to find the time taken by the foo function, T(n). T(n) is a function of its input parameter, the size of the array.", "para_24": "If the start value is less than the end value we calculate the middle position ('mid') between 'start' and 'end' values. Calculation of 'mid' value takes a constant amount of time and is not dependent on size of the array, n. So, the cost of execution of this line of code can be some constant, say c1.\u00a0 Similarly, the if condition execution will take constant time \u0398(1).", "para_25": "In the 'if' condition, we call the foo function recursively. In the first call, we pass 'start' and 'mid' of the array as the function parameters, so in this call, the function works only on n/2 elements (first half of the array). In the second call, we pass 'mid +1' and 'end' as parameters hence in this call the foo function will work on the second half of the array, hence n/2 elements. We will not worry if n is odd, for ease of analysis we shall take n/2 (this is acceptable as we are analyzing for very large values of n. Is that not what asymptotic analysis all about?!)", "para_26": "", "para_27": "\u00a0", "para_28": "Each call on size n/2 will take T(n/2) time. Hence a total of 2T(n/2) time will be taken for the two calls.\u00a0", "para_29": "Say, foo2 is some function takes \u0398(n) time.\u00a0", "para_30": "", "para_31": "The if-statement takes constant time because it is just checking a condition. It takes constant time, constants are in order of 1, i.e. O(1) or better to say .", "para_32": "Then the equation that represents the time taken by the recursive part of the foo function can be written as:", "para_33": "\u00a0", "para_34": "The last  can be neglected.", "para_35": "\u00a0", "para_36": "So, we will get the recurrence relation:", "para_37": "", "para_38": " \u0398(n) represents a linear time complexity, we can replace it with cn where c is some constant (since cn is tightly bound over \u0398(n)). We are making this replacement so that we don't have anything in terms of 'Theta'. Our recurrence relation will then be:", "para_39": "", "para_40": "Let's look at more examples. You may try them for yourself before looking at the explanations.", "para_41": "Example 1: Let us find the recurrence relation for the foo1 function.\u00a0", "para_42": "It is similar to the previous algorithm. When performing the comparison and calculating the mid-value it takes constant time,  . Time taken by foo2 can be represented as .\u00a0When foo1 is called over the first half and second half of the array it takes T(n/2) time. Hence, its recurrence relation will look as shown below. In the recursive case we can ignore \u0398(1) as it has a lower order of growth compared to \u0398(n). That would also be a correct recurrence relation.", "para_43": "", "para_44": "\u0398(1) represents a constant time, we can replace it with c.\u00a0", "para_45": "We can replace \u0398(n) with n, as n has strictly \u0398(n) order of growth. Our recurrence relation modifies to:", "para_46": "", "para_47": "Example 2:\u00a0\u00a0", "para_48": "The if condition check and the return statement runs in a constant time, c1.\u00a0", "para_49": "When the else statement is executed foo(n/2) would take T(n/2) execution time; this call is made twice hence a total of 2T(n/2) for the return statement. Additionally a constant time c2 to check if the 'if' condition fails and then reach the else clause.", "para_50": "The recurrence relation will be:", "para_51": "T(n) = 2T(n/2) + c2 for n>1", "para_52": "T(n) = c1 for n=1", "para_53": "Q. What is the recurrence relation of below foo2 function?"}, "li_sentences": {}}}, "heading_sentences": ["Exploration 2", "2: Recurrence Relations"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {}, "preh2_links": {}}