{"content": {"Introduction": {"para_sentences": {"para_0": "In this section, we will look at a few algorithms that implement the Divide and Conquer Technique (MLO3).\u00a0", "para_1": "While going through the exploration try to answer these questions:"}, "li_sentences": {"ul_0": ["How to approach and solve a problem using the divide-and-conquer strategy?"]}}, "Divide-and-Conquer Algorithms": {"para_sentences": {"para_0": "To solve the problem of sorting an array of numbers we have seen insertion sort in the previous module which had a time complexity of O(n2). Let us look at the 'Merge Sort' algorithm that solves this problem using Divide and Conquer Technique.", "para_1": "Problem: Sort an array of n numbers that are not in sorted order.", "para_2": "To solve this problem using the Divide and Conquer technique, we will first break the problem into two subproblems. We can divide the array of n numbers into arrays of size (n/2). It will be easy to sort an array of size (n/2) than an array of size of n. We can divide the (n/2) sized array further into two arrays of half the size. This can be done until we reach the smallest size of the array which has just one element. One element is by default sorted. Since it is easy to arrange individual elements we can now conquer and combine these individual elements. So, after first combining, we will have smaller arrays of two elements each that are in sorted order. We can arrange these to form bigger sorted arrays. Subsequently sorting the n elements of the whole array. The below animation demonstrates this process.", "para_3": "", "para_4": "We are performing merger sort using Divide and Conquer by following these steps:", "para_5": "Divide: Break the array into two halves, we calculate the middle index position of the array and obtain two sub-arrays.", "para_6": "Conquer: Sort the two subarrays obtained from the divide step.", "para_7": "Combine: Merge the two sorted subarrays to get a single sorted array.", "para_8": "Let us see the implementation, we can implement this in two steps", "para_9": "Step 1 can be achieved by this pseudocode:", "para_10": "\u00a0Does this look familiar? Yes, it is similar to the 'foo' function that we looked in 'Recurrence Relations' Exploration. This code just goes on dividing the array until we reach the single element.", "para_11": "To merge the two smaller arrays after dividing them (remember the smallest sub-array that we get from merge_sort function is already sorted since it has a single element, which is default sorted, out next task is to merge them), we will write a merge function so that we can keep our code clean. To implement the merge function on two sorted subarrays we will check the first element of each subarray and copy the smallest element to our bigger array, then look for the next smallest element among the two subarrays. We can do this with the help of two pointers that iterate through two subarrays. See below interactive slides to understand how this is done (variables i, j are used to iterate through the array elements).", "para_12": "Once we reach the end of any of the subarrays we can copy remaining elements from other subarrays that are not yet copied. One thing to note here is that in the divide step we were not actually creating new arrays but tracking the starting and ending index positions of our subarray. Hence before copying we need to make temporary arrays of our subarrays and then copy to the bigger array.", "para_13": "The pseudocode for merge procedure:", "para_14": "Try implementing the merge sort function merge_sort(Arr,start,end) in the below code editor. It should not return anything but sort Arr by the end of the execution. The solution is in solution.py file. Optionally, you can access the solution from the GitHub link\n\n\nLinks to an external site..", "para_15": "", "para_16": "\u00a0", "para_17": "Analysis of Merge sort implementation:", "para_18": "The time complexity of merge function: The while loop inside the merge function contributes to the maximum execution time. It runs at most n times i.e. the size of the array. Hence it will have a running time of c1n.", "para_19": "The time complexity of merge_sort function: We have seen this before in 'Recurrence Relations' exploration for the 'foo' function. Its recurrence relation will be T(n) = 2T(n/2) + c2\u00a0", "para_20": "The recurrence relation for our merge sort algorithm will be:", "para_21": "T(n) = 2T(n/2) + c1n + c2\u00a0", "para_22": "We can apply the Master Method and obtain the time complexity for this recurrence relation as \u0398(n log n).", "para_23": "Below video explains how to arrive at this intuitively. Access video notes here\n\n\nActions\n\n\nPreview\nDownload\nAlternative formats\n\n.", "para_24": "The video below explains the Quick-sort algorithm, another sorting algorithm that uses the Divide and Conquer technique. Access video notes here\n\n\nActions\n\n\nPreview\nDownload\nAlternative formats\n\n.", "para_25": "\u00a0", "para_26": "Read section 2.3.1 (The divide-and-conquer approach) in CLRS textbook. This section covers a slightly different approach to implement the merge sort algorithm. This section also proves the correctness of the mergesort using the induction technique that we have seen in the previous module."}, "li_sentences": {"ol_0": ["Divide the array until we reach single elements  single elements are by default sorted", "Divide the array until we reach single elements  single elements are by default sorted", "Combine the subarrays obtained from the previous step"]}}, "Exercises": {"para_sentences": {"para_0": "Function definition: search(numList, key)"}, "li_sentences": {"ul_0": ["Search for an element in a list of sorted numbers using Divide and Conquer Technique"]}}}, "heading_sentences": ["Exploration 2", "3", "1: Divide-and-Conquer Algorithms"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]], "ol_0": [[]]}, "preh2_links": {}}