{"content": {"Introduction": {"para_sentences": {"para_0": "A majority of the real-world problems can be divided into subproblems which are represented as nodes and can be constructed to form a graph. For example, if Amazon wants to optimize their delivery routes, they can represent their delivery locations as nodes and form a graph connecting these nodes and solve their problem using the knowledge of solving graph problems.", "para_1": "You might have learned about graphs in your Data Structures course. In this section, we will take a quick look at the terminology and look at the ways of traversing a graph. As you go through this section try to answer the following questions."}, "li_sentences": {"ul_0": ["When to use graphs?", "How to represent a graph?", "Implement Breadth-First Search (BFS) and Depth-First Search for a graph (DFS)?", "Analyze the time complexity of BFS  DFS"]}}, "Graph Introduction": {"para_sentences": {"para_0": "Strong knowledge in graph fundamentals will enable us to better approach the graph-related problems. Read the content presented in the below slides to get familiar with the terminology involving graphs.", "para_1": "Graphs can be represented in two ways", "para_2": "A graph can be represented as a matrix of size |V|x|V|. Cell (i,j) is marked as 1 if there is an edge between i and j vertices. Below is an example. Cell (1,2) is marked 0 while cell (2,1) is marked as 1 since there is a directed edge between 2 and 1.", "para_3": "", "para_4": "\u00a0This representation requires a space of\u00a0 \u03b8(|V|2) to store the graph and access time to check for a node takes\u00a0 \u03b8(1).", "para_5": "In adjacency list, we have vertices in the form of a list, and each element (a vertex) in the list contains another list (or array or linked list) with the elements that are connected to the vertex.", "para_6": "", "para_7": "The array has |V| elements and each element has its adjacent vertices as a list, which are in total |E|. Hence it will need a space of \u03b8(|V|+|E|) , this would be for directed graph. In the case of an undirected graph, each edge will be bidirectional, making a total of 2|E| edges.\u00a0"}, "li_sentences": {"ol_0": ["Adjacency Matrix", "Adjacency List"]}}, "Graph Traversal": {"para_sentences": {"para_0": "To traverse each vertex in the graph, tree-based algorithms are used. The two ways of traversing a graph are:", "para_1": "In Depth-First Search we start at the root and go down an edge as far as we can, then we trace back to cover other depths.", "para_2": "You might have studied about this in-depth in your Data Structures course. For a refresher, you can check the details provided here on  Brilliant's website\n\n\nLinks to an external site. .\u00a0", "para_3": "In Breadth-First Search we start at root and traverse across each level. You can refresh your knowledge on BFS here on Brilliant website\n\n\nLinks to an external site..", "para_4": "You can use the website provided by visualgo\n\n\nLinks to an external site. to visualize BFS and DFS steps.\u00a0", "para_5": "DFS uses the stack data structure for implementation and BFS uses queues, both have a time complexity of O(|V|+|E|)", "para_6": "This video explains how to perform BFS and DFS traversal on a graph.", "para_7": "", "para_8": "BFS is used to solve many real-world problems: in analyzing networks, in GPS navigation systems, in crawlers in web engines, and finding the shortest path.\u00a0", "para_9": "Finding the Shortest Path: We are given a graph and the source node (S) and a destination node (D). We need to find the length of the shortest path between the source and the destination.", "para_10": "We can start at the source and traverse the graph in a breadth-first fashion. We increment the length of the path until we reach the level where the destination node is located.", "para_11": "This process will take a time complexity of O(|V| + |E|)", "para_12": "DFS is used in topographical sorting, in the traveling salesman problem, in solving maze puzzles, etc.\u00a0", "para_13": "In-order traversal of a Binary Search Tree: Given a binary search tree print the nodes in the sorted order.\u00a0", "para_14": "The binary search tree is a binary tree that holds the property that the left children in the tree will be smaller the root node and the right children will be larger than the root node. Traversing binary search tree in DFS order will return the nodes in the order.", "para_15": "This process will take a time complexity of O(|V| + |E|)"}, "li_sentences": {"ol_0": ["Depth-First Search", "Breadth-First Search"]}}}, "heading_sentences": ["Exploration 7", "1: Graph Introduction and Traversal"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]], "ol_0": [[]]}, "preh2_links": {}}