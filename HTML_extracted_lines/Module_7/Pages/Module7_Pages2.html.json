{"content": {"Introduction": {"para_sentences": {"para_0": "You might be aware that most of the courses that you take here at OSU have some other course as prerequisites. For example, the current course CS 325 has CS 261 and (CS 225 or MTH 231 ) as prerequisites. When we pictorially represent the courses in the form of nodes and connect them with their dependencies we get a graph. In this section, we will look at the algorithm to find the ordering of the courses with respect to their prerequisite.", "para_1": "As you go through this exploration try to answer the following questions:"}, "li_sentences": {"ul_0": ["How to implement graph traversal to solve problems?", "What is topological sort and how to implement it?", "What are the applications of the topological sort?"]}}, "Topological Sort": {"para_sentences": {"para_0": "The problem of ordering the courses based on their prerequisites is a form of topological sort problem. A sample course dependencies graph is shown below.", "para_1": "", "para_2": "Course CS 161 is dependent on course MT 112, similarly, course CS 216 is dependent on CS 161 and MT 231 courses.", "para_3": "We need to find the order in which the courses can be taken.\u00a0", "para_4": "The below graph shows one such possible order. This is the topological sort of the nodes in the graph. Note that all the arrows are pointing forward.", "para_5": "", "para_6": "Below is not a topological sort of this graph. There should not be any arrows pointing backwards.", "para_7": "", "para_8": "At a high level, we can see that to get the topological sort we are going down the depth of the graph to find the dependency flow. This can give us an idea to use DFS.\u00a0", "para_9": "Go through the slides below to understand the algorithm.", "para_10": "Note that we can have a different order of the sorted vertices, so the solution returned by the algorithm is not the only solution. Below shows an order of vertices that can also be a solution.\u00a0", "para_11": "", "para_12": "The pseudocode for the algorithm:", "para_13": "We are building the result in a stack. We are using a helper_toposort() helper function to apply recursion on each vertex until we reach the depth of the graph. Once each node is processed we are adding it to the stack.", "para_14": "Time Complexity: Similar to DFS, this algorithm will have O(V+E) time complexity.\u00a0", "para_15": "We can obtain topological sort for 'directed acyclic graphs' but not for undirected graphs or graphs with cycles.\u00a0", "para_16": "Why? In an undirected graph when we pick two nodes connected with the edge we cannot say which node is dependent on the other one, so order doesn't come into the picture. In a graph with cycles, for example if a--> b -->a, then it is difficult to say which node takes priority.\u00a0", "para_17": "We can solve this problem using a naive approach by iterating through each node in the graph. But that will not be efficient. The problem wants us to cover all the nodes in the graph. Let us see how to solve it using graph traversal technique.\u00a0", "para_18": "Topological sort is in many Computer Science applications. When you are installing a package which have a couple of modules that are dependent on each other. Then the topological sort algorithm is used to build a graph of the modules and decide the order in which the modules should be installed. Other applications are in problems like job scheduling."}, "li_sentences": {}}, "Exercises": {"para_sentences": {"para_0": ""}, "li_sentences": {"ul_0": ["In below code editor implement topological sort algorithm"]}}, "Optional Additional Resources": {"para_sentences": {"para_0": "If this topic interests you, then you might find the following optional resources useful."}, "li_sentences": {"ul_0": ["Section 22"]}}}, "heading_sentences": ["Exploration 7", "2: Topological Sort"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]]}, "preh2_links": {}}