{"content": {"Introduction": {"para_sentences": {"para_0": "In this section, we will explore an algorithm that can be used in applications like Uber, Lyft to find the shortest path from a source to destinations, this is called Dijkstra algorithm. It is a Dutch name, where j is either silent or is pronounced like y. Dijkstra is pronounced as Dyk( as in bike ) -stra.\u00a0", "para_1": "As you go through this exploration try to answer the following questions:"}, "li_sentences": {"ul_0": ["What is the Dijkstra algorithm and how to implement it?", "What are the applications of Dijkstra algorithm?"]}}, "The Dijkstra Algorithm": {"para_sentences": {"para_0": "Suppose you want to solve a problem to find 'all food places near me'. Your algorithm should return all the food places and the distance from your location.\u00a0", "para_1": "", "para_2": "\u00a0", "para_3": "To solve this problem we can use Dijkstra's algorithm. Did you notice that the graph is a weighted graph? Dijkstra's algorithm is used to solve similar problems that have a weighted graph but the weights should be non-negative.\u00a0", "para_4": "Let us look at the Dijkstra's algorithm and find the shortest path from node A to all other nodes in the below graph. Let A be the source node and our goal is to find the shortest path to all other nodes from A.", "para_5": "", "para_6": "To begin with, let us look at the method to the shortest path from A to B. If we simply use BFS it will return (A-->B). But the actual shortest path is (A-->D-->B). To solve this let us use the algorithm technique that we learnt before, the greedy algorithm, along with BFS.", "para_7": "The general idea is to pick the locally best choice to obtain a globally optimal solution. Access video notes here\n\n\nActions\n\n\nPreview\nDownload\nAlternative formats\n\n.", "para_8": "\u00a0", "para_9": "\u00a0", "para_10": "The relation that we use to find the local minimum can be written as (consider that we are calculating the distance from node u to node v):", "para_11": "dist[v] = min{ dist[v] , weight[u,v]+dist[u] }", "para_12": "We are setting the initial distance of all nodes to infinity and source node distance to 0.", "para_13": "Then we are looping through all the unvisited nodes and picking the unvisited node that has the least distance from the source node.", "para_14": "Then, we are checking the neighbors of the selected node and calculating the shortest distance using the relation that we discussed above.\u00a0", "para_15": "Finally, we have updated the visited node.", "para_16": "To discuss the time complexity of this algorithm we need to decide upon the data structures we want to use in the code. We are repeatedly looking out for the smallest distance node, this sounds like what a priority queue implemented as min-heap can do for us.", "para_17": "\u00a0If we use the priority queue the pseudocode will be:", "para_18": "The while loop is executed E times for each edge and the inner for loop will be executed V times for each vertex since we are covering each vertex only once. Decrease key and Dequeue takes log V time complexity. Hence, this algorithm will have O((V+E)logV) time complexity.", "para_19": "\u00a0", "para_20": "Lemma: For each x\u00a0\u2208 VisitedNodes, dist(x) = smallestDistance(x)", "para_21": "\u00a0dist(x) is the distance calculated by the algorithm, let us represent it as A(x).", "para_22": "smallestdistance(x) is the correct smallest distance from the source node to x, let us represent it as C(x)", "para_23": "Proof by Induction:", "para_24": "Base Case: When |VisitedNodes| = 1, The first node that is visited is the source node(S). C(x) =0, Our algorithm sets the distance from the source node to 0. So, A(x)=C(x).", "para_25": "Inductive Hypothesis:\u00a0All the k nodes (u1, u2, ... uk ) that are already in the VisitedNodes set have the distance calculated A(x)=C(x).", "para_26": "Inductive Step:", "para_27": "We need to show that the next node that is added to VisitedNode set (say w*) has the smallest distance from S.\u00a0", "para_28": "Let us mark the VisitedNode set by region R", "para_29": "", "para_30": "We will prove this by contradiction.", "para_31": "There must exist a path P from S to w* and this path would cross the region R at some point.", "para_32": "The lenght of path P, len(P) = A(u) + len(u,w*)", "para_33": "Assume that there is another node v outside R on path P that gives us the shortest distance from s to w*.", "para_34": "", "para_35": "len(P) = A(u) + len(uv) + len(vw*)", "para_36": "\u27f9 A(u) + len(u,w*)\u00a0 = A(u) + len(uv) + len(vw*)", "para_37": "Since dijkstra is for non negative weights. len(vw*) >=0", "para_38": "\u27f9 A(u) + len(u,w*)\u00a0 >= A(u) + len(uv)", "para_39": "\u27f9 len(uw*) >= len(uv)", "para_40": "Now, let us invoke the Greedy property used by Dijkstra algorithm.", "para_41": "If there exists a Node v, that has a shorter distance than w*, v would have been visited next not w*. So, our assumption that there exists a node v on outside region R that has shorter distance than w* is false.\u00a0", "para_42": "Hence, w* is the next node with shorter distance outside region R.", "para_43": "By our inductive hypothesis, all the nodes inside R have the best shortest distance. A(u) already has the optimal distance calculated.\u00a0", "para_44": "A(u)+len(uw*) will give us optimal distance of w* from S.", "para_45": "The Dijkstra algorithm does not work with negative edges.\u00a0"}, "li_sentences": {}}, "Exercises": {"para_sentences": {"para_0": "", "para_1": ""}, "li_sentences": {"ul_0": ["Implement Dijkstra algorithm that is discussed in the exploration"]}}, "Optional Additional Resources": {"para_sentences": {"para_0": "Refer to the following resources for additional reading."}, "li_sentences": {"ul_0": ["Algorithms by Jeff Erickson  Chapter 8  section 8"]}}}, "heading_sentences": ["Exploration 7", "3: Dijkstra's algorithm"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]]}, "preh2_links": {}}