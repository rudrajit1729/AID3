{"content": {"Introduction": {"para_sentences": {"para_0": "In the last module, we have seen an algorithmic paradigm to solve a problem that can be broken into smaller subproblems. In some problems, further optimization can be achieved by using a technique called Dynamic Programming. In this section, we will explore the Dynamic Programming technique to solve algorithms.\u00a0", "para_1": "As you go through this section try to answer these questions:"}, "li_sentences": {"ul_0": ["What is Dynamic Programming?", "When to use Dynamic Programming?", "What are the two approaches of Dynamic Programming?"]}}, "Dynamic Programming": {"para_sentences": {"para_0": "Do you remember the Fibonacci Number problem?  This Wiki link\n\n\nLinks to an external site.  can act as a refresher.", "para_1": "To find the nth Fibonacci number the recurrence 'formula' can be given as following. It is little different from recurrence relation, here we represent the values that our function returns for each value of n. When n=0 or n=1, F(n) will return 1; and for other values of n the function F(n) will return F(n-1) + F(n-2). Here F(n) represents our function itself unlike T(n) in recurrence relation in the previous exploration, where T(n) represents the time taken to solve problem of size n.\u00a0", "para_2": "", "para_3": "\u00a0The pseudocode to solve this problem using Divide-and-Conquer:", "para_4": "Let's see the recursion tree representing the recursive calls for n = 5.", "para_5": "", "para_6": "It is good that we are dividing the big problem of calculating for n = 5 into smaller problems to get the final result. The time complexity of this algorithm is 2n/2(Exponential - which is very slow). Did you notice that we are calculating the same smaller problem multiple times? Notice in the recursion tree that we are calculating for n = 3 twice and for n = 2 thrice. We are repeating our work for the same subproblem, aren't we? So, when we ask ourselves if can we make this algorithm to run faster, the answer will be yes. \u00a0We just have to avoid redoing the work of overlapping subproblems by storing the result after solving them for the first time. So, after we find the value for n=3, we will store this result and when we need it again we will use the stored value rather than recalculating it. Similarly, for n=2. This is the idea behind Dynamic Programming.", "para_7": "Dynamic Programming is a powerful algorithm design technique that can be used to solve problems that have strictly overlapping subproblems. There are two approaches that can be used to solve an algorithm using Dynamic Programming: the top-down approach and the bottom-up approach. Let us solve the Fibonacci Number problem to learn about these approaches.", "para_8": "As we have discussed, we can optimize the solution of Fibonacci Number problem (Fib(n) pseudocode) by storing the results of the overlapping subproblems. To achieve this we will create a new variable, FibMemo, of the dictionary datatype, where we can store the results of the subproblems that we calculated. By default, we can also include the base case values into this dictionary variable.", "para_9": "FibMemo = {0:1 , 1:1}", "para_10": "FibMemo[0] = 1", "para_11": "FibMemo[1] = 1", "para_12": "After we calculate the value of a sub-problem we can update our FibMemo variable. Let's say we calculated the value for n = 2, our updated FibMemo will be {0: 1, 1: 1, 2: 2}.", "para_13": "The code for this top-down implementation will be (Why it is called top-down will be answered in a while):", "para_14": "Try executing it in the code editor below. Observe the values printed by the print statements to see the values that are being added to FibMemo[1].", "para_15": "", "para_16": "The below animation demonstrates how the recursion tree grows during each recursive call for n = 5. Notice that we did not work on the entire tree as in the case of Fib(n) algorithm. As you see below we are starting with the n value and we are going down the tree to find the solution for the problem, hence the name top-down approach.", "para_17": "So, Fib_top_down(n) recurses only for distinct values of n for each subsequent recursive sub-call. We memoize (remember) and reuse the subproblem solutions to help solve the problem. This technique of storing temporary results in the top-down approach is called 'memoization' (without 'r'), which is similar to creating a memo.", "para_18": "For every k, that belongs to [1,n] we calculate Fib_top_down(k) once. So, our recurrence relation will be:", "para_19": "T(n)=T(n\u22121)+\u03b8(1)", "para_20": "This would give us a time complexity of \u03b8(n)", "para_21": "Another way of analyzing this would be:", "para_22": "We spend time to calculate only non-memoized values of n, n-1,...1. Memoized calls take constant time \u03b8(1) since we have to only look up the value in the FibMemo structure.\u00a0", "para_23": "Time Complexity\u00a0 = number of Subproblems\u00a0 \u2217\u00a0 time/subproblem", "para_24": "= n\u00a0 \u2217 \u03b8(1) \u00a0[Since we spend constant time during each call which is independent of n]", "para_25": "\u03f5\u03b8(n)", "para_26": "We can slightly modify our code as below to get rid of the global variable FibMemo.", "para_27": "In this approach, we will solve smaller sub-problems first and then combine the results until we solve our actual bigger problem. For the Fibonacci Number problem, we will start with base cases: Fib(0), Fib(1), then we will find Fib(2), Fib(3) and so on until we reach our n value.\u00a0", "para_28": "It is similar to the iterative approach and can be achieved using a loop. The algorithm for this approach will be:", "para_29": "You can execute it in below code editor. As you execute observe how the fib_table is growing with each iteration and the final solution is stored in the last index of the array.\u00a0", "para_30": "", "para_31": "This approach is also called 'tabulation' as we are constructing the table of results of all sub-problems until we reach the value of n for our problem.", "para_32": "Time Complexity Analysis: We are executing a for loop for range n. Hence our time complexity will be \u03b8(n).", "para_33": "In the Top-Down approach, we start with the bigger problem and go down to the base case (go top-down). As we go down we store the solution of the subproblems in extra memory space to avoid re-computation. This is mostly implemented using recursion.\u00a0", "para_34": "In the Bottom-Up approach, we start with the base case and solve bigger problems as we progress until we reach our actual problem (go bottom-up). This is mostly an iterative approach that builds up the solution of the sub-problems and stores the solution in extra memory space.", "para_35": "Based on your understanding of the two approaches answer these questions. If needed you may refer to the explanation and code provided until now in this section.", "para_36": "\u00a0", "para_37": "\u00a0In the next section, we will solve some problems using Dynamic Programming Technique."}, "li_sentences": {}}}, "heading_sentences": ["Exploration 3", "1: Dynamic Programming Fundamentals"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]]}, "preh2_links": {}}