{"content": {"Introduction": {"para_sentences": {"para_0": "Let us look at Change Making Problem in this section and solve it using Dynamic Programming. As you go through this section try to observe the approach we are taking to solve the problem."}, "li_sentences": {}}, "Change Making Problem": {"para_sentences": {"para_0": "Suppose you are programming software for a vending machine. Your vending machine can give change only in the form of coins. Your target is to make sure that your machine gives fewest possible coins. The coin denominations are customisable so that it can be used in any country.\u00a0", "para_1": "Suppose your coin denominations are 1\u00a2, 3\u00a2 and 5\u00a2. We want to make a change for 5\u00a2. We can do this in the following ways:", "para_2": "In our problem, we would be provided with the denominations of the coins and the amount for which we have to make the change. We would return -1 if change cannot be obtained.", "para_3": "Before we proceed with the dynamic programming approaches. Do you want to pause and think about how you would solve it without dynamic programming using brute force or a naive way?", "para_4": "One of the most commonly thought incorrect approach is to start with the maximum denomination of coins. This might not always give the correct solution. For example, when denominations are: \u00a01, 5, 7 and 10, and the amount we need change for is 14. If we start with a coin worth 10 then we would have a total of five coins (10,1,1,1,1). But, the minimum number of coins that can be used are two coins (7,7). This technique of picking the best possible value is called a greedy approach, we will see this in later modules.\u00a0\u00a0", "para_5": "The video explains how to solve the problem and how to write a recurrence relation for this problem. Access video notes here\n\n\nActions\n\n\nPreview\nDownload\nAlternative formats\n\n.", "para_6": "\u00a0", "para_7": "The below code has a recursive solution for the problem. Try to code it before looking at the solution. The solution is in solution.py. Optionally, you can access the solution from the GitHub link\n\n\nLinks to an external site..", "para_8": "", "para_9": "\u00a0", "para_10": "What will be the time complexity of this solution? Look at the recursion tree, in the worst case the amount A might get branched into the total number of possible denominations that are given, which is (n). Hence the time complexity will be exponential, An.", "para_11": "Look at the recursion tree for the sample input values of coins (1, 3, 5) and an amount value of 9. We can notice that we are solving subproblems that are overlapping (few of them have been color-coded for easier identification. If you compete the tree you will find that there are more overlapping sub-problems).", "para_12": "As the amount value increases the overlapping sub-problems would increase. Hence we can use dynamic programming memoization to solve this problem.", "para_13": "To do this, we will need to keep a memo (which can be an array, for example, countmemo[]) of a minimum number of coins needed for an amount value that we calculate as we proceed.\u00a0", "para_14": "We will follow the same steps that we did when performing recursion. For a given amount value we will calculate the possible number of coins needed when using each denomination.\u00a0", "para_15": "Try to attempt this solution by yourself. The below code editor has the solution in a solution.py file which you can refer to if you need help. The explanation for the code is provided below. Optionally, you can access the solution from the GitHub link\n\n\nLinks to an external site..", "para_16": "", "para_17": "\u00a0", "para_18": "We are using a helper function (makechange_topdown_helper) for ease of coding. Our memoization table is an array of size of the amount+1 since we can have at most 'amount' number of values to calculate. This you can observe in the tree, the depth of the tree will be the same as the value of amount if coin worth 1\u00a2 is used. This is initialized to 0.\u00a0", "para_19": "In makechange_topdown_helper function, we iterate through all possible values of coins that we can use and recursively call the helper function with the remaining amount after using a coin. This helper function returns the best possible count of coins found so far.", "para_20": "For each iteration, we set minimum_coins to system.maximum number (some large number)", "para_21": "When we have a valid coin that we can include to make the change, temp_coincount will have a valid value. If temp_coincount value is better than previously calculated minimum_coins (0\u2264temp_coincount<minimum_coins)\u00a0then we replace the minimum_coins with the new count.", "para_22": "It is better if you can run the code with the PyCharm debugger and see how the variables are changing to get a better understanding of the code.", "para_23": "If the amount for which we are calculating change is A, and the total number of denominations that we have is n, then our tree will have a maximum dept of A in the worst case (i.e. when the minimum denomination is 1, then we have nodes representing, A, A-1, A-2.... 1). And for each node, we will check n possible branches. Since we have the results cached, we will do a maximum of n iterations for each denomination of the coin. So, our time complexity will be O(An)", "para_24": "We need an additional space of size A (our countmemo array), hence our code will require O(A) space complexity.", "para_25": "For the bottom-up approach, we will start with the base case and create an array of the number of coins needed for amount values starting from 1 to A (amount value).", "para_26": "Watch the video for the explanation of the bottom-up solution approach. Access video notes here\n\n\nActions\n\n\nPreview\nDownload\nAlternative formats\n\n.", "para_27": "\u00a0", "para_28": "\u00a0", "para_29": "In the below code editor try writing the pseudocode and code for this approach. The solution code is provided in the code editor if you need help. The additional comments provided in the code can help in understanding the code. For better understanding, it is recommended that you run the same in debugger mode in PyCharm and observe the intermediate results. Optionally, you can access the solution from the GitHub link\n\n\nLinks to an external site..", "para_30": "", "para_31": "We are computing A (Amount) number of subproblems, and for each value of A we are iterating through n (number of coin denominations) number of times. Hence the complexity of our code is O(A*n).\u00a0", "para_32": "We need an additional space of size A (our countmemo array), hence our code will need O(A) space complexity.", "para_33": "In the next section, we will consolidate the steps that we can take when solving a problem using the dynamic programming technique.\u00a0"}, "li_sentences": {"ol_0": ["One 5\u00a2 coin = 1 coin", "One 3\u00a2 and Two 1\u00a2 coins = 3 coins", "Five 1\u00a2 coins = 5 coins"]}}}, "heading_sentences": ["Exploration 3", "2: Dynamic Programming - Change Making Problem"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ol_0": [[]]}, "preh2_links": {}}