{"content": {"Introduction": {"para_sentences": {"para_0": "In this section, we will look at the steps that can be taken to solve a problem using dynamic programming and summarize how to identify if a problem is solvable using the dynamic programming technique. We will in turn also solve one of the classic dynamic programming problems - Longest Common Subsequence problem. While you read try to answer the following questions:"}, "li_sentences": {"ul_0": ["What are the steps to solve a problem using Dynamic Programing?", "When to use Dynamic Programming?"]}}, "Where to use Dynamic Programming and Steps": {"para_sentences": {"para_0": "For a problem to be solvable using dynamic programming it must have two characteristics: it should have overlapping subproblems and it should have optimal structure. ", "para_1": "When you read a problem and if you find that it needs optimization (finding the minimum or maximum of something), identify whether the problem has optimal substructure and overlapping subproblems. If your answer is yes, then you can likely use dynamic programming to solve it."}, "li_sentences": {"ul_0": ["Overlapping Subproblems: We have already visited the point regarding overlapping subproblems", "Optimal Substructure: Optimal substructure can be defined as the optimum solution (the solution) of the problem can \u00a0be formed from the optimum solution (solution) of the sub-problems"], "ol_0": ["Identify the parameters that impact the problem", "Identify the subproblem", "Define the recursive formula including the base case", "Implement a naive recursive solution (This is optional  though it will help you get a good understanding of dynamic programming)", "Turn the recursive formulation into dynamic programming algorithm\u00a0  Optimize the recursive solution to use cache (memoization) Implement using the top-down or bottom-up approach", "Optimize the recursive solution to use cache (memoization)", "Implement using the top-down or bottom-up approach"]}}, "Longest Common Subsequence": {"para_sentences": {"para_0": "Given two strings str1 and str2, return the length of their longest common subsequence of characters between the two strings. A subsequence is a sequence that appears in the same relative order, but are not necessarily contiguous. If there is no common subsequence, return 0.", "para_1": "Assume that an empty string is not a subsequence of any string.", "para_2": "Example:", "para_3": "Input: str1 = \"abcdef\", str2 = \"apceg\"", "para_4": "output:\u00a0 3", "para_5": "Explanation: The longest common subsequence is \"ace\" and its length is 3.", "para_6": "Before thinking about the dynamic programming approach, what is your naive approach to solve this problem? Take a pen and paper and think about how would you solve this problem if you were to write an algorithm for this.", "para_7": "Note about this problem: This problem has many real-world applications, for instance when Git needs to merge two files it needs this algorithm, in biometrics -it is used to detect similarities between two genetic codes, and many more.", "para_8": "When we are given two strings (str1 = \"abcdef\", str2 = \"aceg\") our minds can look at it and directly tell the length of the longest common subsequence. Let's decipher the steps that our mind is taking.", "para_9": "We start with a counter in our minds that is initially set to 0.", "para_10": "We then look at the first character in the first string (\"a\") and the first character in the second string (\"a\"), if it is a match we increment the counter by 1.", "para_11": "And move on to the second character of each string (\"b\" and \"c\"). They don't match. So we would keep our pointer on either of the strings static (let's say first string) and increment to the next character in the second string to see if we find a match. Next character is \"e\",\u00a0 which does not match, so we move the pointer forward to compare the next character. This way we do this until we find a match or reach the end of the second string. In this case, there is no match.", "para_12": "Then we come back to the first string and increment the pointer to the next character (\"c\") and compare the second string from the character that was our first case of no-match in our previous step, the character \"c\" (We don't want to start from \"a\" since it has already been matched).", "para_13": "Similarly, we move to our next characters in both the strings.", "para_14": "This gives us an idea about how to solve this problem recursively.", "para_15": "Let us look at the steps now.", "para_16": "Step1: Identify the parameters that impact the problem: Length of string1 and string2 impact our problem.", "para_17": "Step2: Identify the subproblem: In our solution analysis, observe that after we have compared the first characters of the strings, the remaining subproblem is again a longest common subsequence problem, on two shorter strings.\u00a0 The below figure explains this. First, we look at the problem for strings of lengths i, j (i=length of string1, j=length of string2). Since it matched, we are looking for a solution to the problem of size i-1 and j-1.", "para_18": "\u00a0", "para_19": "We can define our subproblem to be:", "para_20": "LCS[i,j]: Longest common subsequence of strings of lengths i and j.", "para_21": "Step3: Define the recursive formula: Based on the understanding from step1 and step2, we can see that when we are matching the first characters of two strings, they would either match or not match, which gives us two cases.\u00a0", "para_22": "As in the above figure when we are solving for LCS[i,j] when the first characters match we will count it as one match and add 1 to the result of substrings of lengths i-1 and j-1. This can be written mathematically as:", "para_23": "LCS[i,j] = 1 + LCS[i-1, j-1]\u00a0 \u00a0When the first characters of str1 of length i and str2 of length j match.", "para_24": "When they don't match, we have two options. The first option is to find the LCS of str1 of length i and str2 of length j-1 (here we are excluding the mismatching character from string2). The second option would be to find the LCS of str1 of length i-1 and str2 of length j (excluding the mismatching character from string1). Then, take the maximum of the two. Below figure demonstrates this.\u00a0", "para_25": "\u00a0", "para_26": "We can write this in the form of an equation as:", "para_27": "LCS[i,j]= max{ LCS[i, j-1] , LCS[i-1 , j] } when the first characters of str1 of length i and str2 of length j do not match.", "para_28": "Finally, the base case, when the length of str1 or str2 is 0 then the LCS value will be 0.", "para_29": "LCS[i,j] = 0 when i = 0 or j = 0", "para_30": "Combining all the cases our recursive formula will be:", "para_31": "\u00a0", "para_32": "Step4: Implement a naive recursive solution", "para_33": "This is optional. You can implement a recursive solution for this problem in the below code editor. This will help you in implementing the dynamic programming solution. The solution is provided in solution.py. Optionally, you can access the solution from the GitHub link\n\n\nLinks to an external site..", "para_34": "", "para_35": "Time Complexity: This is an exponential problem. For every character we have two possible choices, it can either be in the subsequence or it cannot. So worst-case time complexity will be O(2n), where n is the length of the longer string.", "para_36": "Step5: Turn recursive formulation into the dynamic programming algorithm. Let us implement the dynamic programming solution.", "para_37": "Since this problem can be solved by solving the subproblems and the problem asks for a maximum possible length of the sequence (an optimal substructure), this problem can be solved using dynamic programming.", "para_38": "The below video provides an explanation for the bottom-up approach solution to this problem. Access video notes here\n\n\nActions\n\n\nPreview\nDownload\nAlternative formats\n\n.", "para_39": "\u00a0", "para_40": "\u00a0", "para_41": "Based on the explanation try to write the pseudocode for this approach by yourself.", "para_42": "Here are a few hints:", "para_43": "We would need a two-dimensional array to store the results, we need extra space to store the results of the base case. ie. LCS[0,1], LCS[1,0], LCS[0,2] and so on. i.e when we are comparing strings with an empty string.\u00a0 If our strings in our problem are of lengths m and n, we need a 2-D array of size [m+1][n+1]", "para_44": "After we have our 2-D array initialized as:", "para_45": "We can loop through this \"cache\" and fill in the values using the recurrence equation that we wrote.", "para_46": "The below video explains the idea behind the top-down solution. Access video notes here\n\n\nActions\n\n\nPreview\nDownload\nAlternative formats\n\n.", "para_47": "\u00a0", "para_48": "\u00a0", "para_49": "We can write a recursive solution to this approach. Similar to the bottom-up approach we can create a two-dimensional table and return 0 when we approach the base case, i.e. when either of the lengths of the strings is 0.", "para_50": "\"The first approach is top-down with memoization. In this approach, we write the procedure recursively in a natural manner, but modified to save the result of each subproblem (usually in an array or hash table). The procedure now first check to see whether it has previously solved this subproblem. If so, it returns the saved value, saving further computation at this level; if not, the procedure computes the value in the usual manner. We say that the recursive procedure has been memoized; it \u201cremembers\u201d what results it has computed previously. The second approach is the bottom-up method. This approach typically depends on some natural notion of the \u201csize\u201d of a subproblem, such that solving any particular subproblem depends only on solving \u201csmaller\u201d subproblems. We sort the subproblems by size and solve them in size order, smallest first. When solving a particular subproblem, we have already solved all of the smaller subproblems its solution depends upon, and we have saved their solutions. We solve each subproblem only once, and when we first see it, we have already solved all of its prerequisite subproblems. These two approaches yield algorithms with the same asymptotic running time, except in unusual circumstances where the top-down approach does not actually recurse to examine all possible subproblems. The bottom-up approach often has much better constant factors, since it has less overhead for procedure calls.\" [1]"}, "li_sentences": {}}, "Optional Additional Resources": {"para_sentences": {"para_0": "Refer to the following resources for additional reading.", "para_1": "[1] CLRS book, Section 15.1"}, "li_sentences": {"ul_0": ["Section 15"]}}}, "heading_sentences": ["Exploration 3", "3: Dynamic Programming - Longest Common Subsequence Problem"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]], "ol_0": [[]]}, "preh2_links": {}}