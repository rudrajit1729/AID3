{"content": {"Introduction": {"para_sentences": {"para_0": "As mentioned in the overview, a recursive function is a function that calls itself. Each time it calls itself, a separate copy is created that has its own values for its parameters and variables. Of course, if every copy creates another copy, then the recursion will never end, and we'll run out of memory, so it's crucial that every recursive function have one or more base cases. A base case is a case where the function doesn't call itself.", "para_1": "Let's look at a common first example of recursion:", "para_2": "", "para_3": "The condition of the if statement checks whether num is equal to zero. This is the base case. If it's true, then the function does not call itself. However, if the base case is not true, then it calls itself, performs a multiplication with the return value, and returns the result. We could also write it like this:", "para_4": "", "para_5": "The else can be omitted here because if the condition is true, then \"return 1\" is executed, and the function ends before it can reach the recursive call. This is the logic I'll use in the other examples in this lesson.", "para_6": "Python Tutor\n\n\nLinks to an external site. is a helpful site for visualizing what's happening when you run Python code. Try running the above example there."}, "li_sentences": {}}, "The call stack": {"para_sentences": {"para_0": "When running a recursive function, multiple copies of the function will be active at once, but only the most recent one will be executing - the others are paused while waiting for a result. When a recursive call is made, the computer needs to save our place in the current copy of the function, so that we can come back to it later. Then we can start executing a new copy of the function. The computer saves our place in the current copy by storing its information on the call stack, which keeps track of all active function calls. Watch the video \"Flow of execution example for recursion\" to see how this works."}, "li_sentences": {}}, "More examples": {"para_sentences": {"para_0": "Here's a recursive function that finds the greatest common divisor of two integers: ", "para_1": "The base case is when b evenly divides a, in which case b is the greatest common divisor. Otherwise we make a recursive call with the value of b passed in as the value of a in the new function call, and the value of a % b passed in as the value of b in the new function call. Nothing needs to be done with the return values on the way back out of the recursive calls.", "para_2": "Here's a recursive function that computes the hailstone sequence starting from a given number and counts how many steps it takes to reach 1:", "para_3": "", "para_4": "Here the base case is when the sequence arrives at 1. You can see that there are two different recursive cases - one that happens if num is odd, and one that happens if num is even. We add 1 to the return value, since the current copy of hailstone takes one more step to reach 1 than the recursive call does. For example, if we start at 3, the sequence goes: 3, 10, 5, 16, 8, 4, 2, 1. If we find the number of steps it takes to go from 10 to 1, then we can just add 1 more step to get the number of steps it takes to go from 3 to 1."}, "li_sentences": {}}, "Writing a recursive function": {"para_sentences": {"para_0": "Recursion can feel like it's partly magic, because you're writing a function that is calling the function you're still writing. It feels like an M.C. Escher print. The general strategy for designing a recursive function is to identify how a problem can be broken up into a smaller problem of the same kind, plus a bit of work at the current level.", "para_1": "Another bit of advice: don't try to mix recursion and loops, because if you do, there's a very good chance you won't end up with a truly recursive function."}, "li_sentences": {"ul_0": ["In the factorial example  num! is equal to (num-1)! multiplied by num", "In the gcd example  the gcd of a and b is the same as the gcd of b and a % b  which is a smaller problem of the same type", "In the hailstone sequence example  the smaller problem of the same type is counting how many steps it takes to get from the next number in the sequence to 1"]}}, "Exercises": {"para_sentences": {"para_0": "(See the module overview for a link to example solutions.)", "para_1": "1. Write a recursive function called countdown that takes a positive integer parameter and returns a string that counts down from that number to 1. For example, if 5 is passed to the function, it should return the string \"5 4 3 2 1\". You can use string concatenation in your recursive function to build up the return value.", "para_2": "2. Write a recursive function called countup that takes a positive integer parameter and returns a string that counts up from 1 to that number. For example, if 5 is passed to the function, it should return the string \"1 2 3 4 5\". You can use string concatenation in your recursive function to build up the return value.", "para_3": "3. Write a recursive function called sum_countup that takes an integer parameter and returns the sum of all the integers from 1 to that number. For example if the function is passed the value 5, then it should return 15 because 1 + 2 + 3 + 4 + 5 = 15."}, "li_sentences": {}}}, "heading_sentences": ["Exploration: Recursion"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]]}, "preh2_links": {}}