{"content": {"Tuples": {"para_sentences": {"para_0": "Tuples are almost the same thing as a list. There are two minor differences having to do with syntax, and one more significant difference. Let's talk about the syntax first. The first difference is that we use square brackets to create a new list, but we use parentheses to create a new tuple.", "para_1": "The other syntax difference is with tuples that contain only one value. In order for Python to know that it's a tuple, you have to include a trailing comma.", "para_2": "", "para_3": "Although parentheses are used for creating a new tuple, we still use square brackets when indexing or slicing a tuple.", "para_4": "Now let's look at the big difference."}, "li_sentences": {}}, "Mutability vs. immutability": {"para_sentences": {"para_0": "The big important difference between lists and tuples is that lists are mutable, but tuples are immutable. Put more simply, you can change a list, but you can't change a tuple. So far we've seen ways to create new lists based on old lists, but we haven't looked at ways we can change an existing list, with one exception. The sort method doesn't create a new sorted version of the list - it rearranges the existing list into sorted order.", "para_1": "We can't call sort() on\u00a0 tuples because they're immutable.", "para_2": "How else can we mutate (modify) an existing list? Here are a couple of lists we can experiment with.", "para_3": "", "para_4": "We can assign a new value to an existing element of a list like this:", "para_5": "We can also put a slice on the left side of the assignment. In this case the value on the right must be of an iterable type.", "para_6": "The number of elements being assigned can be different than the size of the slice being replaced. (Enter \"birds\" after each example so that you can see what has changed.)", "para_7": "Notice that the slice \"birds[1:1]\" is empty, since a slice goes up to the second index, but doesn't include it.", "para_8": "The slice \"birds[:]\" would create a slice of the entire list - that is, it would create a copy of the list, which can also be done using list():", "para_9": "We can also append items to the end of a list using append, and delete items from a list using del (notice that append uses method notation, but del uses operator notation).", "para_10": "None of these assignments will work with tuples because they cannot be mutated. But if tuples are essentially lists that we can't change, why use them at all? One reason is that there are times when an immutable type is required. For example, only immutable types can be used as keys in dictionaries, another way of storing and manipulating data that we'll talk about soon. Another reason is that if the elements shouldn't get changed, using a tuple instead of a list makes sure that won't happen by accident.", "para_11": "If you have a tuple that contains mutable objects, the tuple itself is immutable because you cannot change which objects it contains, however the mutable objects it contains can still be mutated.", "para_12": "In the page on functions we saw that changing a parameter in a function did not change the value of the variable that was passed in the function call, and said we'd discuss the reason in a later module. The reason is because the variable we passed referred to an immutable type. Integers, like tuples, are immutable and cannot be changed. In fact, lists are the only mutable type we've looked at so far - all the others we've seen are immutable (objects of user-defined classes, which we looked at in module 5, are also mutable). If a variable refers to a list, and we pass that list to a function, then the function can change the actual list that was passed.", "para_13": "", "para_14": "Here we see that the variable num_list got changed by the function we passed it to. The function could have changed the list in other ways such as adding or removing elements, but I wanted to show an example very similar to the one I showed in the page on functions, only using a list instead of an integer.", "para_15": "You might have an objection at this point. How can ints, floats, bools and strings be immutable? It seems like we've changed values of those types before. We'll take a look at this in the next section, which talks about object references and identity.", "para_16": "Beware of this gotcha: In Python, if you use a mutable value as a default argument, a new object won't be created every time the function is called. \u00a0Instead, a new object will be created the first time the function is called without an argument, and that same object will be used for later calls to the function (that don't have an argument). \u00a0So if you have a list as a default argument, the same list would be used every time the function is called without that argument, which is probably not what you would expect or want. \u00a0For example:", "para_17": "The first time you call it without an argument, it will return [1]. \u00a0The next time you call it without an argument, it will return [1, 1], then [1, 1, 1], etc. \u00a0In order to avoid this behavior, do the following instead:", "para_18": "Do not use mutable default arguments for any of the assignments in this course."}, "li_sentences": {}}}, "heading_sentences": ["Exploration: Tuples and Mutability vs", " Immutability"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {}, "preh2_links": {}}