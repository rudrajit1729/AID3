{"content": {"in, not in": {"para_sentences": {"para_0": "There are operators called in and not in that can be used to check whether or not a string contains another string. For example:", "para_1": ""}, "li_sentences": {}}, "find()": {"para_sentences": {"para_0": "If you need to know where a string occurs inside another string, you can use the find() method, which returns the leftmost index of the substring within the other string:", "para_1": "If the string does not appear as a substring of the other word, then find() returns -1. You can also search within a specified section of the string:", "para_2": "The end index works the same as for ranges - the section being searched extends up to, but does not include, the end index."}, "li_sentences": {}}, "len()": {"para_sentences": {"para_0": "There is a function called len that returns the length of a string:"}, "li_sentences": {}}, "upper() and lower()": {"para_sentences": {"para_0": "You can use the upper() and lower() methods to get an upper-case or lower-case version of a string."}, "li_sentences": {}}, "Operators vs. functions vs. methods": {"para_sentences": {"para_0": "Notice the different syntax we've used for in and not in, len, and upper and lower. The in and not in operators are used between two values (the operands) in a format similar to arithmetic operators, like * and /. These arithmetic operators each have two numeric operands. However in the examples for in and not in, we used strings for both operands.", "para_1": "The len function is called in the same way we've called other functions - we first give the name of the function, and then list inside parentheses any values we're passing to the function. In this case we're passing a string to the function.", "para_2": "The\u00a0find,\u00a0upper,\u00a0and\u00a0lower\u00a0methods\u00a0are called using the dot notation syntax that we use with objects. That's because strings (like everything else in Python) are objects that have certain methods defined for them. In this case, we don't have to pass the string as an argument. You can think of it as politely asking the string if it would be so kind as to carry out the requested operation. (The string is implicitly passed to the method as the\u00a0self\u00a0argument.)"}, "li_sentences": {}}, "Indexing": {"para_sentences": {"para_0": "We can get the character at a certain position, or index, in a string by indexing into the string. Imagine numbering the letters of a string in order, starting with zero. So in the string \"onyx\", the \"o\" is at index zero, the \"n\" is at index 1, the \"y\" is at index 2, and the \"x\" is at index 3. Notice that the index of the last character is the length of the string minus 1. We index into a string by following it with square brackets containing the index that we want to access.", "para_1": "", "para_2": "We can also use negative indices, in which case we count from the back of the string. The character at index -1 would be the last character in the string, the one at -2 would be the next-to-last character, etc."}, "li_sentences": {}}, "Slicing": {"para_sentences": {"para_0": "\"Slicing\" a string gives you back part of that string, based on the indices for the start and end of the part you want.", "para_1": "Notice that the substring you get back starts at the first index, and goes up to, but does not include the second index (similar to making a range). If you omit the first index, the substring starts at the first character. If you omit the second index, the substring ends at the last character.", "para_2": "The character at index 6 (the seventh character) doesn't get included in the first slice, but does in the second slice. If you omit both indices:", "para_3": "then you get a copy of the whole string.", "para_4": "We can also specify the \"stride\" for a slice, which allows us to get a slice that has every other character (a stride of 2), every third character (a stride of 3), etc.", "para_5": "Because the first and second index were omitted, they default to the start and end of the string, respectively. The stride of 2 makes it so only every 2nd letter is included. The stride can also be negative, which makes us count backwards in the string, in which case the first index needs to be larger than the second. We can reverse a string like this (when the stride is negative, the first index will default to the end of the string and the second index will default to the beginning):"}, "li_sentences": {}}, "Comparison operators": {"para_sentences": {"para_0": "We can use the normal comparison operators with strings, where if it's true that A < B, then that means A comes before B in lexicographic order (dictionary order).", "para_1": "However, there's an important caveat: because characters are encoded as numbers, and because upper-case letters have lower numbers than lower-case letters, Python will say that upper-case letters come before lower-case letters.", "para_2": "One way to handle this is to convert the strings to upper-case (or lower-case) before comparing them."}, "li_sentences": {}}, "Exercises": {"para_sentences": {"para_0": "(See the module overview for a link to example solutions.)", "para_1": "1. Write a function called last_char that takes a string parameter and returns the last letter of that string.", "para_2": "2. Write a function called midstring that takes a string parameter and returns a copy of that string minus its first and last letters. If the string passed in has only has 1 or 2 letters, the function should return the empty string \"\".", "para_3": "3. Write a function called sort_two_strings that takes two string parameters and returns a single string of both of them in dictionary order, ignoring case. For example, if the strings \"aardvark\" and \"Zebra\" are passed, it should return \"aardvark Zebra\".", "para_4": "4. A palindrome is a string that reads the same forward or backward. Write a function called is_pal that takes a string parameter and returns True if that string is a palindrome, but returns False otherwise."}, "li_sentences": {}}}, "heading_sentences": ["Exploration: String Manipulation"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {}, "preh2_links": {}}