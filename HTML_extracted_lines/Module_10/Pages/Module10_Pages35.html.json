{"content": {"Introduction": {"para_sentences": {"para_0": "You've seen a few of the different types that are built into Python. Using classes, we can define new types. Once we've defined a class (a user-defined type), we can then create specific objects of that class. Here's an illustration of the relationship between a class and a few specific objects of that class:", "para_1": "", "para_2": "As you learned in the previous module, functions are a way of helping organize code in a simpler way. Instead of having to repeat the same code in many different places, you can just have it in one place, which makes it much easier to think about and maintain. Classes provide an additional level of helping organize code in a simpler way. Instead of having various related data and the various functions that need to operate on that data just scattered around various parts of your code, you can bundle together that data and those functions into a single class, which makes it much easier to think about and maintain. With the small programs you're working on now that may not be apparent yet, but when we get to larger programs, the benefits should become more clear.", "para_3": "Here's a simple example class:", "para_4": "", "para_5": "The class keyword is used to define a class. The name of a class should start with a capital letter. Classes should have a docstring that describes their purpose and any additional information someone might need to know when using the class. Functions that are part of a class are often referred to as methods. This Pet class only has a single method with the special name __init__ (two underscores on either side). This method creates a Pet with whatever species and name you passed to that method. The species and name are the data members (or fields or attributes) of the Pet class. The special parameter self refers to the object itself. You don't call the __init__ method by name - instead you use the name of the class. You also don't pass an argument for self - that's done automatically for you. Let's create a couple of Pets:", "para_6": "Each of these lines creates a new Pet object. The Pet class is just a general blueprint for Pets. To create a specific Pet object, we use the name of the class as shown above. This automatically calls the __init__ method. An object is sometimes referred to as an \"instance\" of a class, and creating an object as \"instantiating\" a class. Once we've created an object, we can access its attributes using dot notation:", "para_7": "We would also use dot notation to call an object's methods, but our Pet class doesn't have any besides __init__, so let's look at another example:", "para_8": "", "para_9": "Notice that the area and perimeter methods have only the self parameter. They don't need to be passed the width or height, because they are already part of the object, and can be accessed via the self parameter. Now that we've defined the Rectangle class, here's an example of using it:", "para_10": "Note that we call the method on a Rectangle object, NOT on the Rectangle class:"}, "li_sentences": {}}, "How do you know what to put in a class?": {"para_sentences": {"para_0": "When designing a class, we need to decide what are the relevant features, for our purposes, of the thing we're representing. That helps us figure out what data and functions the class should have. For example, if what we're concerned with is the selling of cars, then price would be one of the relevant features, but if we're only concerned with the driving of cars, then it wouldn't be."}, "li_sentences": {}}, "\"Private\" class members": {"para_sentences": {"para_0": "Some languages have a keyword (\"private\" in Java and C++) that means a certain class data member or method can't be accessed from outside the class. The methods that are part of the class can still access it, but not external code that uses the class. Python does not have such a keyword. Instead, it has the convention that any data member or method whose name begins with an underscore should be treated as private even though the language doesn't enforce it. Normally all data members of a class are designated as private, as well as any functions that are just for internal use by the class. We discuss this more below.", "para_1": "Here's a BankAccount class:", "para_2": "", "para_3": "Notice that for class names, instead of separating words with underscores (which is called \"snake case\"), we start each new word with a capital letter (which is called \"camel case\"). Here's an example of using the BankAccount class:", "para_4": "If we want for other code to be able to access a private data member, we need to provide get and/or set methods. A get method just returns the current value of the corresponding data member. A set method takes a parameter and just sets the corresponding data member to the value of the parameter. The normal naming convention is \"get_\" or \"set_\" followed by the name of the corresponding data member. For the account ID we provided both get and set methods. For the balance, we only provided a get method, since the balance is changed via the deposit and withdraw methods.", "para_5": "You might wonder why we would want to have private data members if it means writing more methods. The reason is that it allows us to control access to the data members. If we don't want a data member to be accessed, we can just not write get and/or set methods for it. Or if a data member should only be set to a certain range of values, then we can check for that in the set method. If a data member is public, then it can be changed to anything from anywhere, which can make your program logic harder to understand and debug. Controlling access to data members this way is referred to as information hiding\u00a0(or data hiding).", "para_6": "Information hiding is important because it allows you to control how certain parts of the class are accessed.\u00a0 It allows you to separate interface (the names and expected parameters of any public functions) from implementation (the definitions of those functions, and also any private data members or private functions).\u00a0\u00a0Making that distinction makes it easier to modify the class later on.\u00a0 If you allow the user to directly access any part of the class, then some users' code will end up depending on specific details of the implementation, which means that if you change the implementation later, you'll break any code that depends on it.\u00a0 It makes code much more modular if you provide a defined interface.\u00a0 The specific implementation details can then be allowed to change as long as the interface remains the same.\u00a0", "para_7": "In addition to private data members, we can also indicate that methods are private in the same way. The reason we would make a method private is if it's just meant for internal use by the class and not part of the way we expect users to interact with the class. An example of this would be if we had a Fraction class and we wanted the Fractions to always be in reduced form. To accomplish this, we could have a greatest_common_divisor() function that can be used within the class. However, we wouldn't normally expect users to interact with a Fraction object by asking it to find the gcd of two integers - we expect them to do more explicitly Fraction-y things, like printing the Fraction or multiplying it by another Fraction. Finding the gcd of two integers is an implementation detail that can be \"hidden\" from the users."}, "li_sentences": {}}, "Everything is an object": {"para_sentences": {"para_0": "In Python, everything is an object. Strings, integers, and all other values are objects. Functions are objects. Even the special value None is an object. Given the power and popularity of Python (and other object-oriented languages), it's clear that object-oriented design can be a valuable tool for organizing code in ways that help make programming easier. It can feel very abstract at first, but it's definitely worthwhile to master the concepts involved."}, "li_sentences": {}}, "Printing objects of user-defined classes": {"para_sentences": {"para_0": "If you try to print an object of a user-defined class, you'll get something like this:", "para_1": "which just tells you what class it belongs to and its address in memory. \u00a0In order to print out the values of the data members, you need to specifically access those data members in the print statement, as shown earlier. \u00a0In CS 162, you'll learn how to re-define the behavior of the print function for objects of user-defined classes."}, "li_sentences": {}}, "Exercises": {"para_sentences": {"para_0": "(See the module overview for a link to example solutions.)", "para_1": "1. Define a class named HourlyWorker that has three private data members: _name, _ID, and _wage. The class should have a docstring and an init method. The parameters to the init method should be in the order listed above.", "para_2": "Example of how someone might use your class:\u00a0", "para_3": "Expected output:", "para_4": "2. Define a class named Box that has three private data members: _length, _width, and _height. The class should have a docstring and an init method. The parameters to the init method should be in the order listed above. The class should also have a method named volume that returns the volume of the Box, and a method named surface_area that returns the surface area of the Box.", "para_5": "Example of how someone might use your class:", "para_6": "Expected output:", "para_7": "\u00a0"}, "li_sentences": {}}}, "heading_sentences": ["Exploration: Classes and Objects"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {}, "preh2_links": {}}