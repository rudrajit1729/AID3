{"content": {"Introduction": {"para_sentences": {"para_0": "In this section, we will solve the 0-1 knapsack problem. ( MLO2 )", "para_1": "As you go through this section, try to answer the following question:"}, "li_sentences": {"ul_0": ["How to solve the 0-1 knapsack problem?"]}}, "The 0-1 knapsack Problem": {"para_sentences": {"para_0": "We have seen that in the 0-1 knapsack problem we have only one copy of each item. When finding the optimal solution we have only two options when we consider one item: either we chose it or we don't choose it, hence the name 0-1.", "para_1": "For example,", "para_2": "Consider items with weights w = [4, 9, 3, 5, 7]", "para_3": "and their corresponding values v = [10, 25, 13, 20, 8]", "para_4": "The knapsack that we have cannot carry weight more than W = 10", "para_5": "", "para_6": "What is the best way to maximize the value of our knapsack if we have only one copy of each item?", "para_7": "\u00a0", "para_8": "Let us follow the steps that we have seen before to solve a dynamic programming problem to approach the solution of the 0-1 knapsack problem.", "para_9": "Step 1: The parameters that impact the problem: As with the unbound knapsack problem, the capacity of the knapsack is a parameter that impacts the solution of our problem. Additionally, the available items also impact our solution. For instance, if we included an item A, we cannot consider it again since we have only one copy of it. Hence, these will be our two parameters that would impact our problem.", "para_10": "Step 2: Identify the subproblem: Along with the capacity, our subproblem should also contain information about the items that we have used. Here, we are speaking about the two parameters defined above. Hence, our subproblem will be of form f(x,i).", "para_11": "f(x,i) = optimal solution for a knapsack of capacity x using first i items ( 1\u2264i\u2264n). ", "para_12": "So, for each ith item, we will consider:", "para_13": "What will be the optimal solution if we do include it", "para_14": "What will be the optimal solution if we don't include it", "para_15": "We will evaluate these two cases and consider the one that results in the best value.", "para_16": "Step 3: Define the recurrence function including the base case.\u00a0", "para_17": "Try for yourself to write the recurrence function for the 0-1 knapsack problem. Watch the below video for the explanation. Access video notes here\n\n\nActions\n\n\nPreview\nDownload\nAlternative formats\n\n.", "para_18": "\u00a0", "para_19": "Hence the recurrence formula will be:", "para_20": "  ", "para_21": "1\u2264i\u2264n", "para_22": "Step 4: Turn the recurrence formula into the dynamic programming algorithm.", "para_23": "Before we approach the solution let us look at the cache structure to store the subproblem results.", "para_24": "We need to track two parameters as listed in our recurrence relation equation, the value of x and i, so we need a 2-dimensional array. Let us visually see why we need a 2-dimensional array.", "para_25": "If our w=[4, 2, 5, 6, 7]; v=[10, 25, 13, 20, 8] and W = 7.", "para_26": "When we are evaluating a subproblem, we are iterating through each item and we are calculating the value obtained by including it and by not including it; and we are taking the maximum of the two. The below figure shows us the case when we are evaluating for the subproblem of capacity 1, and we are considering the first item (i=1). This gives us the value of f(1,1) (The first 1 represents the capacity and the second 1 represents the ith item, the first item in this case).", "para_27": "", "para_28": "\u00a0Similarly, by evaluating the second item for x=1, we will obtain the value for f(1,2). By evaluating the third item, we will obtain f(1,3) and so on.", "para_29": "Once we are done calculating all the values for our x=1 subproblem we shall calculate for the next subproblem of capacity x=2.", "para_30": "Evaluating the first item for x=2 capacity will give us f(2,1). This leads us to a two-dimensional table as shown below. We obtain the solution for the problem when we reach the last cell in the table, where we reach the value of our W and n; which is f(7,5) in the current example.", "para_31": "Our base cases value would be 0 if either x=0 or i=0.", "para_32": "With this understanding of the cache, try to write the pseudocode for solving the 0-1 knapsack problem using the bottom-up approach of dynamic programming.", "para_33": "Pseudocode Explanation:", "para_34": "First, we are creating a two-dimensional array. Then, we are looping through each item for each value of smaller capacity bags (0 to W). Then we are calculating the optimal solution for f(x,i) using the recurrence formula that we discussed before.", "para_35": "By default, we are assigning a current value of cache (in below line) to be same as the best solution obtained with all the previous items, which refers to the case of not including the ith item.", "para_36": "dp[x,i]=dp[x,i-1]", "para_37": "Based on the pseudocode, try writing the code for the knapsack problem in the below editor window. The solution is provided in solution.py file. Optionally, you can access the solution from the GitHub link\n\n\nLinks to an external site..", "para_38": "", "para_39": "Time Complexity analysis: We are iterating through two for loops, one for all possible weight values until the capacity W of the knapsack, and the second loop to iterate over all possible n items. This gives us a time complexity of O(n*W).", "para_40": "\u00a0"}, "li_sentences": {}}}, "heading_sentences": ["Exploration 4", "2: Dynamic Programming - 0-1 Knapsack Problem"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]]}, "preh2_links": {}}