{"content": {"Introduction": {"para_sentences": {"para_0": "In this section, we will look into an interesting algorithm solving technique called backtracking. We will cover an overview of the idea behind this technique and solve a simple problem using the backtracking technique.\u00a0", "para_1": "As you go through this section, try to answer the following questions:"}, "li_sentences": {"ul_0": ["What is the backtracking technique?", "How to identify if a problem can be solved using the backtracking technique?", "What is the difference between the problems that can be solved using dynamic programming vs those that can be solved using the backtracking technique?", "How to implement a backtracking algorithm?"]}}, "Backtracking Technique": {"para_sentences": {"para_0": "Suppose we want to solve a maze puzzle. We will first start at the entry point (marked with red arrow). From there we have two possible choices that we could take path A or path B.", "para_1": "", "para_2": "Let us say we decide to take choice A, and we walk along the blue line. Once we reach the dead end we realize that we have not taken a correct choice and we return back to the point where we could take path B.\u00a0", "para_3": "", "para_4": "After walking further on path B, at the junction X we again have two choices and suppose we take path C. After walking a little we realize that it does not lead us to end. So we again backtrack and we follow this process until we reach our goal.", "para_5": "", "para_6": "Maze image source: Wikipedia\n\n\nLinks to an external site..", "para_7": "Did you realize how we take a possible path (a choice), we stop exploring that path once we realize that it does not lead us to our goal and we backtrack our steps till the point where we can explore a new path? This is the exact technique of backtracking algorithms.", "para_8": "In this technique, you evaluate every possibility. We stop the evaluation if we meet any constraints and take your steps back until you are exhausted with all possible paths.", "para_9": "So, in the backtracking technique might appear we go on solving until we meet an end (or a constraint) and we sense that it would not lead us to the solution.", "para_10": "How do we identify if using the backtracking technique is appropriate for a given problem?\u00a0Basically, if the problem asks for any of the following then it is can be solved using backtracking:", "para_11": "\u00a0"}, "li_sentences": {"ul_0": ["We want to 'generate all' possible answers", "We want a valid solution rather than an optimum solution based on some value (When asked for an optimum solution we want to think about Dynamic Programming)"]}}, "Permutations Problem": {"para_sentences": {"para_0": "Problem description: You are given a string of characters. You have to print all possible combinations of those characters (all permutations). You should not repeat any character. Assume that you will be given distinct characters in the string.", "para_1": "Example:", "para_2": "Input: \"ABC\"", "para_3": "Output:", "para_4": "ABC ACB BAC BCA CAB CBA", "para_5": "Note: If there are n characters in the string, the possible permutations would be n!. In the above example, there were 3 characters in the string, hence we have 3! = 6 possible permutations in the result.", "para_6": "Let us solve the example of input: ABC.", "para_7": "There are many ways to approach this problem, let us look at the backtracking technique.", "para_8": "We start with the available characters. Our first combination can start with character A or B or C. If our first character starts with A (A _ _), we have two possible choices to make from B and C. If we choose B. We have only one choice to make, that is C. Now, we are left with no more choices and our resulting string is of length 3 and is one of the possible combinations. Since we have no more choices to make now, we backtrack till A _ _, and this time we choose C. And repeat our steps, until we find all possible permutations.\u00a0", "para_9": "The below video explains the backtracking technique for solving this problem. Access video notes here\n\n\nActions\n\n\nPreview\nDownload\nAlternative formats\n\n.", "para_10": "\u00a0", "para_11": "\u00a0", "para_12": "Try writing the solution in the code editor below. There are many ways to solve this problem. One approach is provided in solution.py file. Optionally, you can access the solution from the GitHub link\n\n\nLinks to an external site..", "para_13": "", "para_14": "\u00a0", "para_15": "Code Explanation:", "para_16": "We are looping through each of the available characters using the for loop. We add our choice to our result if it was not chosen previously. Then we recursively call our \"permutations\" function to complete our results with available choices.\u00a0", "para_17": "Once we have exhausted all the possible choices we backtrack by removing the last characters before exploring other available choices for the recently emptied space.\u00a0", "para_18": "Time Complexity: If you look at the tree structure in the video, in the first level we have n possible nodes, and in the next level each node expands to n-1 leaves, and further down, next level has n-2 leaves per node. Hence our we are performing a total of n\u2217(n\u22121)\u2217(n\u22122)\u2217....\u2217(1)=n!", "para_19": "This gives us a time complexity of O(n!)."}, "li_sentences": {}}, "Exercises": {"para_sentences": {"para_0": "Example:", "para_1": "Input: [1,2,3]", "para_2": "Output: [[1, 2, 3], [1, 2], [1, 3], [1], [2, 3], [2], [3], []]", "para_3": "Note: An empty set is also included in the powerset.", "para_4": "Hint: Refer to 'Permutations problem', in this case, we need to additionally perform backtracking after removing each of the possible options in the question.", "para_5": "\u00a0"}, "li_sentences": {"ul_0": ["Given a set of n distinct numbers return its power set"]}}}, "heading_sentences": ["Exploration 4", "4: Backtracking"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]]}, "preh2_links": {}}