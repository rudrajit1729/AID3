{"content": {"Introduction": {"para_sentences": {"para_0": "Until now we have looked at different problems that can be solved using the Dynamic Programming approach. For instance, we looked at the longest common subsequence problem - we solved for the length of the longest common subsequence between two strings, but we did not find the subsequence itself. In this section, we will look at the way of finding an optimal solution for some of the dynamic programming problems.", "para_1": "As you go through this section try to answer the following questions:"}, "li_sentences": {"ul_0": ["How to identify if a problem has an optimal solution vs the optimal solution?", "How to write an algorithm to find an optimal solution?"]}}, "Optimal Solution": {"para_sentences": {"para_0": "We have seen that we can solve optimization problems using dynamic programming. These problems have many possible solutions as opposed to a single solution.", "para_1": "For instance, let's say we want to find the optimal solution for the longest possible subsequence between two strings \"AXYBC\" and \"ABCXY\". What is the length of the longest possible subsequence? It is 3. And what is the longest possible subsequence? It can be either \"ABC\" or \"AXY\". Both are correct answers. This is what we mean when we say that optimization problems have 'an' optimal solution vs 'the' optimal solution. Our target in solving the problems in this section would be to find an optimal solution.\u00a0", "para_2": "In the previous module, we have seen the code to obtain the length of the longest common subsequence of two strings.\u00a0", "para_3": "Below is equation and code for the bottom-up approach.", "para_4": "\u00a0", "para_5": "In this solution, we returned the length of the longest common subsequence between two strings str1 and str2. If we want to obtain the longest common subsequence itself, and not just the length, how would we solve it?", "para_6": "For this, we can use the cache table to build the solution. We will start at cache[m][n] and trace backwards. If the str1[m] and str2[n] are same then we know that it is part of the longest common subsequence. If str1[m] and str2[n] are not the same we will take our step backwards towards the largest adjacent entry between cache[m][n-1] and cache[m-1][n]. The below video explains this. Access video notes here\n\n\nActions\n\n\nPreview\nDownload\nAlternative formats\n\n.", "para_7": "\u00a0", "para_8": "\u00a0", "para_9": "So, we can use the recurrence equation and the cached two-dimensional array to obtain an optimal solution. Based on your understanding from the video try to code the solution in the below code editor. If you feel stuck the solution is provided in the file solution.py. Optionally, you can access the solution from the GitHub link\n\n\nLinks to an external site..", "para_10": "", "para_11": "Code explanation: In the first if condition, we are comparing the corresponding characters of the string from the 2-D array.\u00a0", "para_12": "If the characters don't match we just go back to the \"current\" cell in the 2-D array and accepting that answer", "para_13": "As discussed in the video we need to reverse the final string that we obtained. The below the line of code is one of the ways of doing it.", "para_14": "Time complexity: In the worst case if we compare and retrace all the characters of both the strings \"optimalsolution_LCS\" subroutine will take an extra O(m+n) time complexity.\u00a0", "para_15": "Let us revisit the change-making problem that we saw in the previous module.", "para_16": "Problem: We were given some denominations of coins and an amount value, A. We had to find the minimum number of coins necessary to make the change for the given amount. This time, we don't want to return the minimum number of coins but we want to print the coin denominations that can be used to make the change. We still need to satisfy the condition of returning the minimum number of coins.\u00a0", "para_17": "As a refresher, here is the recurrence equation and the code that we discussed before. If you find it difficult to recollect, it is advisable to study the exploration Dynamic Programming - Change Making Problem and come back to this section.", "para_18": "OPT[amount] = min{OPT[amount-di]+1 } ; di ranges over all possible denominations.\u00a0", "para_19": "Explanation of the approach to solve the problem: We saved the minimum possible number of coins for each amount value starting from 1 to amount in the\u00a0 'min_count_table' as shown in the below animation.", "para_20": "Let us say the amount = 6; coin denominations = [1,3,5].", "para_21": "Now we need to keep track of the coins that were used to form the amount value. For example, for amount 2 the coin of denomination 1 is used. We can store this in the coin_used array for value 2. coin_used[2]=1 (1 represents denomination 1). To find all the coins that were used for value 2: we can say denomination 1, and the solution for the remaining amount, i.e 2-1=1. So we will look at the solution for the coins used for value 1, which is again a denomination 1.\u00a0", "para_22": "Similarly, to find the solution for amount = 4, we can use coin of denomination 3 and the solution for the remaining value of 1 (4-3), which can be found by looking at the solution for amount=1. Below animation demonstrates this.", "para_23": "To find the coins that form our solution we will look at the coin_used[6], which gives us 3 as one of the coins that can be used. To find the remaining coins we check for the remaining amount that is left after using a coin of denomination 3, it gives us 6-3 = 3. So to find the coins used for amount 3, we will again look at the coin_used array for value 3 (coin_used[3]), this gives us a coin of denomination 3. After considering the second coin, the remaining amount will be 3-3=0, indicating no more coins to be used. Hence our solution will be coins of denomination 3,3.", "para_24": "You can attempt to write a solution for this in below code editor. The solution is provided in solution.py file. Optionally, you can access the solution from the GitHub link\n\n\nLinks to an external site..", "para_25": ""}, "li_sentences": {}}, "Exercises": {"para_sentences": {"para_0": "Example: w = [4,9,3,5,7]", "para_1": "\u00a0values v = [10,25,13,20,8]", "para_2": "The knapsack that we have cannot carry weight more than W = 10", "para_3": "Your output could return one of the optimal solutions: [5,5]", "para_4": "Hint: You can refer to the Change Making Problem.\u00a0", "para_5": "The solution is provided in solution.py file. Optionally, you can access the solution from the GitHub link\n\n\nLinks to an external site..", "para_6": ""}, "li_sentences": {"ul_0": ["Consider the unbound knapsack problem that we saw in the previous exploration"]}}}, "heading_sentences": ["Exploration 4", "3: Dynamic Programming - Find Optimal Solutions"], "__pre_h2__": {"pre_h2_para_sentences": {}, "pre_h2_li_sentences": {}}, "content_links": {"ul_0": [[]]}, "preh2_links": {}}